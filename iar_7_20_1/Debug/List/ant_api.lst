###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Apr/2016  16:27:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\drivers\ant_api.c
#    Command line =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\drivers\ant_api.c
#        --preprocess=cl
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -lC
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -o
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\ -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\bsp\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\drivers\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\application\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\libraries\captouch\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\ant_api.lst
#    Object file  =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\Obj\ant_api.o
#
###############################################################################

C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\drivers\ant_api.c
      1          /***********************************************************************************************************************
      2          File: ant_api.c                                                               
      3          
      4          Description:
      5          ANT user interface.  No initialization or state machine requried.  This file exposes the source code
      6          for all public functions that work with ant.c.  Seperating it keep sit a little more manageable.
      7          
      8          Once the ANT radio has been configured, all messaging from the ANT device is handled through 
      9          the incoming queue G_sAntApplicationMsgList.  The application is responsible for checking this
     10          queue for messages that belong to it and must manage timing and handle appropriate updates per 
     11          the ANT messaging protocol.  This should be no problem on the regular 1ms loop timing of the main 
     12          system (assuming ANT message rate is less than 1kHz).  Faster systems or burst messaging will need 
     13          to be handled seperately as an add-on to this API.
     14          
     15          
     16          ------------------------------------------------------------------------------------------------------------------------
     17          API:
     18          Types
     19          
     20          typedef enum {ANT_UNCONFIGURED, ANT_CONFIGURED, ANT_OPEN, ANT_CLOSED} AntChannelStatusType;
     21          typedef enum {BROADCAST, ACKNOWLEDGED, BURST, CONTROL} AntDataMessageType;
     22          
     23          
     24          ***ANT CONFIGURATION / STATUS FUNCTIONS***
     25          bool AntChannelConfig(bool)
     26          All channel configuration is sent to the ANT device and TRUE is returned if successful.
     27          This requires a global data structure to be set up in the task.  It is intended to run to completion inside
     28          the application's initialization section.
     29          
     30          bool AntOpenChannel(void)
     31          Queues a request to open the configured channel.
     32          Returns TRUE if message is successfully queued.  Application should monitor AntRadioStatus()
     33          for channel status.
     34          e.g. 
     35          if(AntOpenChannel())
     36          {
     37            ApplicationState = ApplicationWaitForOpen;
     38          }
     39          
     40          bool AntCloseChannel(void)
     41          Queues a request to close the configured channel.
     42          Returns TRUE if message is successfully queued.  Application should monitor AntRadioStatus()
     43          for channel status.
     44          if(AntCloseChannel())
     45          {
     46            ApplicationState = ApplicationWaitForClose;
     47          }
     48          
     49          bool AntUnassignChannel(void)
     50          Quees a request to unassign the ANT channel.
     51          Returns TRUE if message is successfully queued.  Application should monitor AntRadioStatus()
     52          for channel status.
     53          if(AntUnassignChannel())
     54          {
     55            ApplicationState = ApplicationWaitForChannelAssignment;
     56          }
     57          
     58          AntChannelStatus AntRadioStatus(void)
     59          Query the ANT radio channel status.
     60          
     61          
     62          ***ANT DATA FUNCTIONS***
     63          bool AntQueueBroadcastMessage(u8 *pu8Data_)
     64          Queue a broadcast data message.
     65          
     66          bool AntQueueAcknowledgedMessage(u8 *pu8Data_)
     67          Queue an acknowledged data message.
     68          
     69          bool AntReadData(void)
     70          Check the incoming message buffer for any message from the ANT system.  If no messages are present,
     71          returns FALSE.  If message is there, returns TRUE and application can read G_asAntApiCurrentData
     72          to get message info.
     73          
     74          
     75          ***********************************************************************************************************************/
     76          
     77          #include "configuration.h"
     78          
     79          
     80          /***********************************************************************************************************************
     81          Global variable definitions with scope across entire project.
     82          All Global variable names shall start with "G_<type>AntApi"
     83          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     84          u32 G_u32AntApiCurrentDataTimeStamp = 0;                                /* Current G_u32SystemTime1s */
   \                     G_u32AntApiCurrentDataTimeStamp:
   \   00000000                      DS8 4
     85          

   \                                 In section .bss, align 1
     86          AntApplicationMessageType G_eAntApiCurrentMessageClass = ANT_EMPTY;  /* Type of data */
   \                     G_eAntApiCurrentMessageClass:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     87          u8 G_au8AntApiCurrentData[ANT_APPLICATION_MESSAGE_BYTES];               /* Array for message data */
   \                     G_au8AntApiCurrentData:
   \   00000000                      DS8 8
     88          
     89          /*----------------------------------------------------------------------------*/
     90          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
     91          and indicate what file the variable is defined in. */
     92          extern u32 G_u32SystemFlags;                              /* From main.c */
     93          extern u32 G_u32ApplicationFlags;                         /* From main.c */
     94          
     95          extern volatile u32 G_u32SystemTime1ms;                   /* From board-specific source file */
     96          extern volatile u32 G_u32SystemTime1s;                    /* From board-specific source file */
     97          
     98          extern volatile u32 ANT_SSP_FLAGS;                        /* From configuration.h */
     99          
    100          extern u32 G_u32AntFlags;                                     /* From ant.c */
    101          extern AntApplicationMsgListType *G_sAntApplicationMsgList;   /* From ant.c */
    102          extern AntSetupDataType G_stAntSetupData;                     /* From ant.c */
    103          
    104          extern u8 G_au8AntMessageOk[];                                /* From ant.c */
    105          extern u8 G_au8AntMessageFail[];                              /* From ant.c */
    106          extern u8 G_au8AntMessageAssign[];                            /* From ant.c */
    107          extern u8 G_au8AntMessageUnassign[];                          /* From ant.c */
    108          extern u8 G_au8AntMessageUnhandled[];                         /* From ant.c */
    109          extern u8 G_au8AntMessageSetup[];                             /* From ant.c */
    110          extern u8 G_au8AntMessageClose[];                             /* From ant.c */
    111          extern u8 G_au8AntMessageOpen[];                              /* From ant.c */
    112          extern u8 G_au8AntMessageInit[];                              /* From ant.c */
    113          extern u8 G_au8AntMessageInitFail[];                          /* From ant.c */
    114          extern u8 G_au8AntMessageNoAnt[];                             /* From ant.c */
    115          
    116          
    117          /***********************************************************************************************************************
    118          Global variable definitions with scope limited to this local application.
    119          Variable names shall start with "AntApi_<type>Name" and be declared as static.
    120          ***********************************************************************************************************************/
    121          
    122          
    123          /***********************************************************************************************************************
    124          Function Definitions
    125          ***********************************************************************************************************************/
    126          
    127          /*------------------------------------------------------------------------------
    128          Function: AntChannelConfig
    129          
    130          Description:
    131          Completely configures the ANT channel with an application's required parameters 
    132          for communication.
    133          
    134          *** This function violates 1ms system timing and should only be used during initialization ***
    135          
    136          Requires:
    137            - All Global ANT configuration variables have been assigned to the application's
    138              required values.
    139            - An ANT channel is not currently opened.
    140          
    141          Promises:
    142            - Channel, Channel ID, message period, radio frequency and radio power are configured.
    143            - Returns TRUE if configuration is successful
    144          */

   \                                 In section .text, align 2, keep-with-next
    145          bool AntChannelConfig(bool bMaster_)
    146          {
   \                     AntChannelConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
    147            u8 au8ANTAssignChannel0[]    = {MESG_ASSIGN_CHANNEL_SIZE, MESG_ASSIGN_CHANNEL_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntChannelType, G_stAntSetupData.AntNetwork, CS};
   \   00000006   0xA802             ADD      R0,SP,#+8
   \   00000008   0x....             LDR.N    R1,??DataTable7
   \   0000000A   0xC90C             LDM      R1!,{R2,R3}
   \   0000000C   0xC00C             STM      R0!,{R2,R3}
   \   0000000E   0x3908             SUBS     R1,R1,#+8
   \   00000010   0x3808             SUBS     R0,R0,#+8
   \   00000012   0x....             LDR.N    R0,??DataTable7_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF88D 0x000A      STRB     R0,[SP, #+10]
   \   0000001A   0x....             LDR.N    R0,??DataTable7_1
   \   0000001C   0x7840             LDRB     R0,[R0, #+1]
   \   0000001E   0xF88D 0x000B      STRB     R0,[SP, #+11]
   \   00000022   0x....             LDR.N    R0,??DataTable7_1
   \   00000024   0x7880             LDRB     R0,[R0, #+2]
   \   00000026   0xF88D 0x000C      STRB     R0,[SP, #+12]
    148            u8 au8ANTSetChannelID0[]     = {MESG_CHANNEL_ID_SIZE, MESG_CHANNEL_ID_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntSerialLo, G_stAntSetupData.AntSerialHi, G_stAntSetupData.AntDeviceType, G_stAntSetupData.AntTransmissionType, CS};
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable7_2
   \   0000002E   0xC90C             LDM      R1!,{R2,R3}
   \   00000030   0xC00C             STM      R0!,{R2,R3}
   \   00000032   0x3908             SUBS     R1,R1,#+8
   \   00000034   0x3808             SUBS     R0,R0,#+8
   \   00000036   0x....             LDR.N    R0,??DataTable7_1
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000003E   0x....             LDR.N    R0,??DataTable7_1
   \   00000040   0x78C0             LDRB     R0,[R0, #+3]
   \   00000042   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000046   0x....             LDR.N    R0,??DataTable7_1
   \   00000048   0x7900             LDRB     R0,[R0, #+4]
   \   0000004A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000004E   0x....             LDR.N    R0,??DataTable7_1
   \   00000050   0x7940             LDRB     R0,[R0, #+5]
   \   00000052   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   00000056   0x....             LDR.N    R0,??DataTable7_1
   \   00000058   0x7980             LDRB     R0,[R0, #+6]
   \   0000005A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    149            u8 au8ANTSetChannelPeriod0[] = {MESG_CHANNEL_MESG_PERIOD_SIZE, MESG_CHANNEL_MESG_PERIOD_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntChannelPeriodLo, G_stAntSetupData.AntChannelPeriodHi, CS};
   \   0000005E   0xA804             ADD      R0,SP,#+16
   \   00000060   0x....             LDR.N    R1,??DataTable7_3
   \   00000062   0xC90C             LDM      R1!,{R2,R3}
   \   00000064   0xC00C             STM      R0!,{R2,R3}
   \   00000066   0x3908             SUBS     R1,R1,#+8
   \   00000068   0x3808             SUBS     R0,R0,#+8
   \   0000006A   0x....             LDR.N    R0,??DataTable7_1
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0xF88D 0x0012      STRB     R0,[SP, #+18]
   \   00000072   0x....             LDR.N    R0,??DataTable7_1
   \   00000074   0x79C0             LDRB     R0,[R0, #+7]
   \   00000076   0xF88D 0x0013      STRB     R0,[SP, #+19]
   \   0000007A   0x....             LDR.N    R0,??DataTable7_1
   \   0000007C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000007E   0xF88D 0x0014      STRB     R0,[SP, #+20]
    150            u8 au8ANTSetChannelRFFreq0[] = {MESG_CHANNEL_RADIO_FREQ_SIZE, MESG_CHANNEL_RADIO_FREQ_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntFrequency, CS};           
   \   00000082   0xA808             ADD      R0,SP,#+32
   \   00000084   0x....             LDR.N    R1,??DataTable7_4
   \   00000086   0xC90C             LDM      R1!,{R2,R3}
   \   00000088   0xC00C             STM      R0!,{R2,R3}
   \   0000008A   0x3908             SUBS     R1,R1,#+8
   \   0000008C   0x3808             SUBS     R0,R0,#+8
   \   0000008E   0x....             LDR.N    R0,??DataTable7_1
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF88D 0x0022      STRB     R0,[SP, #+34]
   \   00000096   0x....             LDR.N    R0,??DataTable7_1
   \   00000098   0x7A40             LDRB     R0,[R0, #+9]
   \   0000009A   0xF88D 0x0023      STRB     R0,[SP, #+35]
    151            u8 au8ANTSetChannelPower0[]  = {MESG_RADIO_TX_POWER_SIZE, MESG_RADIO_TX_POWER_ID, G_stAntSetupData.AntChannel, G_stAntSetupData.AntTxPower, CS};        
   \   0000009E   0xA806             ADD      R0,SP,#+24
   \   000000A0   0x....             LDR.N    R1,??DataTable7_5
   \   000000A2   0xC90C             LDM      R1!,{R2,R3}
   \   000000A4   0xC00C             STM      R0!,{R2,R3}
   \   000000A6   0x3908             SUBS     R1,R1,#+8
   \   000000A8   0x3808             SUBS     R0,R0,#+8
   \   000000AA   0x....             LDR.N    R0,??DataTable7_1
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0xF88D 0x001A      STRB     R0,[SP, #+26]
   \   000000B2   0x....             LDR.N    R0,??DataTable7_1
   \   000000B4   0x7A80             LDRB     R0,[R0, #+10]
   \   000000B6   0xF88D 0x001B      STRB     R0,[SP, #+27]
    152           
    153            u8 u8ErrorCount = 0;	
   \   000000BA   0x2500             MOVS     R5,#+0
    154          
    155            G_u32AntFlags &= ~_ANT_FLAGS_CMD_ERROR;
   \   000000BC   0x....             LDR.N    R0,??DataTable7_6
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF030 0x0002      BICS     R0,R0,#0x2
   \   000000C4   0x....             LDR.N    R1,??DataTable7_6
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    156          
    157            /* Adjust the channel type if configuration for a slave device */
    158            if(!bMaster_)
   \   000000C8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CA   0x2C00             CMP      R4,#+0
   \   000000CC   0xD105             BNE.N    ??AntChannelConfig_0
    159            {
    160              au8ANTAssignChannel0[3] = CHANNEL_TYPE_SLAVE;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF88D 0x000B      STRB     R0,[SP, #+11]
    161              G_stAntSetupData.AntChannelType = CHANNEL_TYPE_SLAVE;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x....             LDR.N    R1,??DataTable7_1
   \   000000D8   0x7048             STRB     R0,[R1, #+1]
    162            }
    163            
    164            /* Assign the channel */
    165            au8ANTAssignChannel0[5] = AntCalculateTxChecksum(au8ANTAssignChannel0);
   \                     ??AntChannelConfig_0: (+1)
   \   000000DA   0xA802             ADD      R0,SP,#+8
   \   000000DC   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000E0   0xF88D 0x000D      STRB     R0,[SP, #+13]
    166            AntTxMessage(au8ANTAssignChannel0);
   \   000000E4   0xA802             ADD      R0,SP,#+8
   \   000000E6   0x.... 0x....      BL       AntTxMessage
    167            u8ErrorCount += AntExpectResponse(MESG_ASSIGN_CHANNEL_ID, ANT_MSG_TIMEOUT_MS);
   \   000000EA   0xF44F 0x717A      MOV      R1,#+1000
   \   000000EE   0x2042             MOVS     R0,#+66
   \   000000F0   0x.... 0x....      BL       AntExpectResponse
   \   000000F4   0x1940             ADDS     R0,R0,R5
   \   000000F6   0x0005             MOVS     R5,R0
    168          
    169            /* Assign the channel ID */
    170            au8ANTSetChannelID0[7] = AntCalculateTxChecksum(au8ANTSetChannelID0);
   \   000000F8   0xA800             ADD      R0,SP,#+0
   \   000000FA   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000FE   0xF88D 0x0007      STRB     R0,[SP, #+7]
    171            AntTxMessage(au8ANTSetChannelID0);
   \   00000102   0xA800             ADD      R0,SP,#+0
   \   00000104   0x.... 0x....      BL       AntTxMessage
    172            u8ErrorCount += AntExpectResponse(MESG_CHANNEL_ID_ID, ANT_MSG_TIMEOUT_MS);
   \   00000108   0xF44F 0x717A      MOV      R1,#+1000
   \   0000010C   0x2051             MOVS     R0,#+81
   \   0000010E   0x.... 0x....      BL       AntExpectResponse
   \   00000112   0x1940             ADDS     R0,R0,R5
   \   00000114   0x0005             MOVS     R5,R0
    173              
    174            /* Assign the channel period */
    175            au8ANTSetChannelPeriod0[5] = AntCalculateTxChecksum(au8ANTSetChannelPeriod0);
   \   00000116   0xA804             ADD      R0,SP,#+16
   \   00000118   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000011C   0xF88D 0x0015      STRB     R0,[SP, #+21]
    176            AntTxMessage(au8ANTSetChannelPeriod0);
   \   00000120   0xA804             ADD      R0,SP,#+16
   \   00000122   0x.... 0x....      BL       AntTxMessage
    177            u8ErrorCount += AntExpectResponse(MESG_CHANNEL_MESG_PERIOD_ID, ANT_MSG_TIMEOUT_MS);
   \   00000126   0xF44F 0x717A      MOV      R1,#+1000
   \   0000012A   0x2043             MOVS     R0,#+67
   \   0000012C   0x.... 0x....      BL       AntExpectResponse
   \   00000130   0x1940             ADDS     R0,R0,R5
   \   00000132   0x0005             MOVS     R5,R0
    178              
    179            /* Assign the channel frequency */
    180            au8ANTSetChannelRFFreq0[4] = AntCalculateTxChecksum(au8ANTSetChannelRFFreq0);
   \   00000134   0xA808             ADD      R0,SP,#+32
   \   00000136   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000013A   0xF88D 0x0024      STRB     R0,[SP, #+36]
    181            AntTxMessage(au8ANTSetChannelRFFreq0);
   \   0000013E   0xA808             ADD      R0,SP,#+32
   \   00000140   0x.... 0x....      BL       AntTxMessage
    182            u8ErrorCount += AntExpectResponse(MESG_CHANNEL_RADIO_FREQ_ID, ANT_MSG_TIMEOUT_MS);
   \   00000144   0xF44F 0x717A      MOV      R1,#+1000
   \   00000148   0x2045             MOVS     R0,#+69
   \   0000014A   0x.... 0x....      BL       AntExpectResponse
   \   0000014E   0x1940             ADDS     R0,R0,R5
   \   00000150   0x0005             MOVS     R5,R0
    183          
    184            /* Assign the channel power */
    185            au8ANTSetChannelPower0[4] = AntCalculateTxChecksum(au8ANTSetChannelPower0);
   \   00000152   0xA806             ADD      R0,SP,#+24
   \   00000154   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000158   0xF88D 0x001C      STRB     R0,[SP, #+28]
    186            AntTxMessage(au8ANTSetChannelPower0);
   \   0000015C   0xA806             ADD      R0,SP,#+24
   \   0000015E   0x.... 0x....      BL       AntTxMessage
    187            u8ErrorCount += AntExpectResponse(MESG_RADIO_TX_POWER_ID, ANT_MSG_TIMEOUT_MS);
   \   00000162   0xF44F 0x717A      MOV      R1,#+1000
   \   00000166   0x2047             MOVS     R0,#+71
   \   00000168   0x.... 0x....      BL       AntExpectResponse
   \   0000016C   0x1940             ADDS     R0,R0,R5
   \   0000016E   0x0005             MOVS     R5,R0
    188            
    189            /* If any errors were collected, clear the ANT_GOOD flag */ 
    190            /* Announce channel status on the debug port */
    191            DebugPrintf(G_au8AntMessageSetup);
   \   00000170   0x....             LDR.N    R0,??DataTable7_7
   \   00000172   0x.... 0x....      BL       DebugPrintf
    192            if(u8ErrorCount)
   \   00000176   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000178   0x2D00             CMP      R5,#+0
   \   0000017A   0xD00A             BEQ.N    ??AntChannelConfig_1
    193            {
    194              G_u32SystemFlags &= ~_APPLICATION_FLAGS_ANT;  
   \   0000017C   0x....             LDR.N    R0,??DataTable7_8
   \   0000017E   0x6800             LDR      R0,[R0, #+0]
   \   00000180   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000184   0x....             LDR.N    R1,??DataTable7_8
   \   00000186   0x6008             STR      R0,[R1, #+0]
    195              DebugPrintf(G_au8AntMessageFail);
   \   00000188   0x....             LDR.N    R0,??DataTable7_9
   \   0000018A   0x.... 0x....      BL       DebugPrintf
    196              return(FALSE);
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0xE009             B.N      ??AntChannelConfig_2
    197            }
    198            else
    199            {
    200              DebugPrintf(G_au8AntMessageOk);
   \                     ??AntChannelConfig_1: (+1)
   \   00000192   0x....             LDR.N    R0,??DataTable7_10
   \   00000194   0x.... 0x....      BL       DebugPrintf
    201              G_u32AntFlags |= _ANT_FLAGS_CHANNEL_CONFIGURED;
   \   00000198   0x....             LDR.N    R0,??DataTable7_6
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   000001A0   0x....             LDR.N    R1,??DataTable7_6
   \   000001A2   0x6008             STR      R0,[R1, #+0]
    202              return(TRUE);
   \   000001A4   0x2001             MOVS     R0,#+1
   \                     ??AntChannelConfig_2: (+1)
   \   000001A6   0xB00B             ADD      SP,SP,#+44
   \   000001A8   0xBD30             POP      {R4,R5,PC}       ;; return
    203            }
    204          
    205          } /* end AntChannelConfig() */
    206          
    207          
    208          /*------------------------------------------------------------------------------
    209          Function: AntOpenChannel
    210          
    211          Description:
    212          Queues the Open Channel message on the configured ANT channel.  This does not actually indicate
    213          that the channel has been opened successfully -- the calling task must monitor _ANT_FLAGS_CHANNEL_OPEN
    214          to determine if channel opens successfully.
    215            
    216          Requires:
    217            - ANT channel is correctly configured.
    218          
    219          Promises:
    220            - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    221            - Otherwise returns FALSE
    222           
    223          */

   \                                 In section .text, align 2, keep-with-next
    224          bool AntOpenChannel(void)
    225          {
   \                     AntOpenChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    226            u8 au8AntOpenChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_CHANNEL_ID, G_stAntSetupData.AntChannel, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_11
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    227          
    228            /* Update the checksum value and queue the open channel message */
    229            au8AntOpenChannel[3] = AntCalculateTxChecksum(au8AntOpenChannel);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    230            G_u32AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   0000001C   0x....             LDR.N    R0,??DataTable7_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   00000024   0x....             LDR.N    R1,??DataTable7_6
   \   00000026   0x6008             STR      R0,[R1, #+0]
    231           
    232            return( AntQueueOutgoingMessage(au8AntOpenChannel) );
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   0000002E   0xBD02             POP      {R1,PC}          ;; return
    233            
    234          } /* end AntOpenChannel() */
    235          
    236          
    237          /*------------------------------------------------------------------------------
    238          Function: AntCloseChannel
    239          
    240          Description:
    241          Requests that an ANT channel is closed.  Issuing MESG_CLOSE_CHANNEL_ID does not
    242          guarantee that the channel closes, and ANT response to this message does not
    243          indicate that the channel is closed (a seperate message will be sent when the 
    244          channel actually closes which usually happens on the next ANT message period).
    245            
    246          Requires:
    247            - ANT channel is correctly configured and should be open.
    248          
    249          Promises:
    250            - If channel close message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    251            - Otherwise returns FALSE
    252          */

   \                                 In section .text, align 2, keep-with-next
    253          bool AntCloseChannel(void)
    254          {
   \                     AntCloseChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255            u8 au8AntCloseChannel[] = {MESG_CLOSE_CHANNEL_SIZE, MESG_CLOSE_CHANNEL_ID, G_stAntSetupData.AntChannel, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_12
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    256          
    257            /* Update the checksum value and queue the close channel message*/
    258            au8AntCloseChannel[3] = AntCalculateTxChecksum(au8AntCloseChannel);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    259            G_u32AntFlags |= _ANT_FLAGS_CHANNEL_CLOSE_PENDING;
   \   0000001C   0x....             LDR.N    R0,??DataTable7_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   00000024   0x....             LDR.N    R1,??DataTable7_6
   \   00000026   0x6008             STR      R0,[R1, #+0]
    260            
    261            return( AntQueueOutgoingMessage(au8AntCloseChannel) );
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   0000002E   0xBD02             POP      {R1,PC}          ;; return
    262          
    263          } /* end AntCloseChannel() */
    264          
    265          
    266          /*------------------------------------------------------------------------------
    267          Function: AntUnassignChannel
    268          
    269          Description:
    270          Queues message to unassigns the current ANT channel so it can be reconfigured.
    271            
    272          Requires:
    273            - ANT channel is closed
    274          
    275          Promises:
    276            - ANT channel unassign message is queued; application should monitor AntRadioStatus()
    277          */

   \                                 In section .text, align 2, keep-with-next
    278          bool AntUnassignChannel(void)
    279          {
   \                     AntUnassignChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    280            u8 au8AntUnassignChannel[] = {MESG_UNASSIGN_CHANNEL_SIZE, MESG_UNASSIGN_CHANNEL_ID, G_stAntSetupData.AntChannel, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable7_13
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable7_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    281          
    282            /* Update checksum and queue the unassign channel message */
    283            au8AntUnassignChannel[3] = AntCalculateTxChecksum(au8AntUnassignChannel);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    284            G_u32AntFlags &= ~_ANT_FLAGS_CHANNEL_CONFIGURED;
   \   0000001C   0x....             LDR.N    R0,??DataTable7_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000024   0x....             LDR.N    R1,??DataTable7_6
   \   00000026   0x6008             STR      R0,[R1, #+0]
    285            return( AntQueueOutgoingMessage(au8AntUnassignChannel) );
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   0000002E   0xBD02             POP      {R1,PC}          ;; return
    286          
    287          } /* end AntUnassignChannel() */
    288          
    289          
    290          /*------------------------------------------------------------------------------
    291          Function: AntRadioStatus
    292          
    293          Description:
    294          Returns the current radio status to the application.
    295            
    296          Requires:
    297            - G_u32AntFlags are up to date
    298          
    299          Promises:
    300            - Returns one of {ANT_UNCONFIGURED, ANT_CLOSING, ANT_OPEN, ANT_CLOSED}
    301          
    302          */

   \                                 In section .text, align 2, keep-with-next
    303          AntChannelStatusType AntRadioStatus(void)
    304          {
    305            if(G_u32AntFlags & _ANT_FLAGS_CHANNEL_CONFIGURED)
   \                     AntRadioStatus: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_6
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0380             LSLS     R0,R0,#+14
   \   00000006   0xD50D             BPL.N    ??AntRadioStatus_0
    306            {
    307              if(G_u32AntFlags & _ANT_FLAGS_CHANNEL_CLOSE_PENDING)
   \   00000008   0x....             LDR.N    R0,??DataTable7_6
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x02C0             LSLS     R0,R0,#+11
   \   0000000E   0xD501             BPL.N    ??AntRadioStatus_1
    308              {
    309                return ANT_CLOSING;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE008             B.N      ??AntRadioStatus_2
    310              }
    311              else if(G_u32AntFlags & _ANT_FLAGS_CHANNEL_OPEN)
   \                     ??AntRadioStatus_1: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable7_6
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0300             LSLS     R0,R0,#+12
   \   0000001A   0xD501             BPL.N    ??AntRadioStatus_3
    312              {
    313                return ANT_OPEN;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE002             B.N      ??AntRadioStatus_2
    314              }
    315              else
    316              {
    317                return ANT_CLOSED;
   \                     ??AntRadioStatus_3: (+1)
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0xE000             B.N      ??AntRadioStatus_2
    318              }
    319            }
    320            else
    321            {
    322              return ANT_UNCONFIGURED;
   \                     ??AntRadioStatus_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??AntRadioStatus_2: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    323            }
    324            
    325            
    326          } /* end AntRadioStatus () */
    327          
    328          
    329          /***ANT DATA FUNCTIONS***/
    330          
    331          /*-----------------------------------------------------------------------------/
    332          Function: AntQueueBroadcastMessage
    333          
    334          Description:
    335          Adds an ANT broadcast message to the outgoing messages list.  
    336          
    337          Requires:
    338            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    339          
    340          Promises:
    341            - Returns TRUE if the entry is added successfully.
    342          */

   \                                 In section .text, align 2, keep-with-next
    343          bool AntQueueBroadcastMessage(u8 *pu8Data_)
    344          {
   \                     AntQueueBroadcastMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    345            static u8 au8AntBroadcastDataMessage[] = {MESG_DATA_SIZE, MESG_BROADCAST_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
    346          
    347            /* Update the dynamic message data */
    348            au8AntBroadcastDataMessage[2] = G_stAntSetupData.AntChannel;
   \   00000004   0x....             LDR.N    R0,??DataTable7_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable7_14
   \   0000000A   0x7088             STRB     R0,[R1, #+2]
    349            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??AntQueueBroadcastMessage_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xDA07             BGE.N    ??AntQueueBroadcastMessage_1
    350            {
    351              au8AntBroadcastDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x5D01             LDRB     R1,[R0, R4]
   \   00000018   0x....             LDR.N    R2,??DataTable7_14
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x1882             ADDS     R2,R0,R2
   \   0000001E   0x70D1             STRB     R1,[R2, #+3]
    352            }
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F4             B.N      ??AntQueueBroadcastMessage_0
    353           
    354            au8AntBroadcastDataMessage[11] = AntCalculateTxChecksum(au8AntBroadcastDataMessage);
   \                     ??AntQueueBroadcastMessage_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable7_14
   \   00000026   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000002A   0x....             LDR.N    R1,??DataTable7_14
   \   0000002C   0x72C8             STRB     R0,[R1, #+11]
    355            return( AntQueueOutgoingMessage(au8AntBroadcastDataMessage) );
   \   0000002E   0x....             LDR.N    R0,??DataTable7_14
   \   00000030   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    356          
    357          } /* end AntQueueBroadcastMessage */

   \                                 In section .data, align 4
   \                     ??au8AntBroadcastDataMessage:
   \   00000000   0x09 0x4E          DC8 9, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    358          
    359          
    360          /*-----------------------------------------------------------------------------/
    361          Function: AntQueueAcknowledgedMessage
    362          
    363          Description:
    364          Adds an ANT Acknowledged message to the outgoing messages list.  
    365          
    366          Requires:
    367            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    368          
    369          Promises:
    370            - Returns TRUE if the entry is added successfully.
    371          */

   \                                 In section .text, align 2, keep-with-next
    372          bool AntQueueAcknowledgedMessage(u8 *pu8Data_)
    373          {
   \                     AntQueueAcknowledgedMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    374            static u8 au8AntAckDataMessage[] = {MESG_DATA_SIZE, MESG_ACKNOWLEDGED_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
    375          
    376            /* Update the dynamic message data */
    377            au8AntAckDataMessage[2] = G_stAntSetupData.AntChannel;
   \   00000004   0x....             LDR.N    R0,??DataTable7_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable7_15
   \   0000000A   0x7088             STRB     R0,[R1, #+2]
    378            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??AntQueueAcknowledgedMessage_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xDA07             BGE.N    ??AntQueueAcknowledgedMessage_1
    379            {
    380              au8AntAckDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x5D01             LDRB     R1,[R0, R4]
   \   00000018   0x....             LDR.N    R2,??DataTable7_15
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x1882             ADDS     R2,R0,R2
   \   0000001E   0x70D1             STRB     R1,[R2, #+3]
    381            }
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F4             B.N      ??AntQueueAcknowledgedMessage_0
    382           
    383            au8AntAckDataMessage[11] = AntCalculateTxChecksum(au8AntAckDataMessage);
   \                     ??AntQueueAcknowledgedMessage_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable7_15
   \   00000026   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000002A   0x....             LDR.N    R1,??DataTable7_15
   \   0000002C   0x72C8             STRB     R0,[R1, #+11]
    384            return( AntQueueOutgoingMessage(au8AntAckDataMessage) );
   \   0000002E   0x....             LDR.N    R0,??DataTable7_15
   \   00000030   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    385           
    386          } /* end AntQueueAcknowledgedMessage */

   \                                 In section .data, align 4
   \                     ??au8AntAckDataMessage:
   \   00000000   0x09 0x4F          DC8 9, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    387          
    388          /*-----------------------------------------------------------------------------/
    389          Function: AntReadData
    390          
    391          Description:
    392          Checks for any new messages from ANT. The messages are of type AntLocalMessageType
    393          so the application must decide what the data means.
    394          
    395          Requires:
    396            - 
    397          
    398          Promises:
    399            - Returns TRUE if there is new data; G_asAntApiCurrentData holds the message type and data message
    400            - Returns FALSE if no new data is present (G_asAntApiCurrentData unchanged)
    401          */

   \                                 In section .text, align 2, keep-with-next
    402          bool AntReadData(void)
    403          {
   \                     AntReadData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    404            u8 *pu8Parser;
    405            
    406            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable7_16
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01D             BEQ.N    ??AntReadData_0
    407            {
    408              G_u32AntApiCurrentDataTimeStamp = G_sAntApplicationMsgList->u32TimeStamp;
   \   0000000A   0x....             LDR.N    R0,??DataTable7_16
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable7_17
   \   00000012   0x6008             STR      R0,[R1, #+0]
    409              G_eAntApiCurrentMessageClass = G_sAntApplicationMsgList->eMessageType;
   \   00000014   0x....             LDR.N    R0,??DataTable7_16
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7900             LDRB     R0,[R0, #+4]
   \   0000001A   0x....             LDR.N    R1,??DataTable7_18
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    410              pu8Parser = &(G_sAntApplicationMsgList->au8MessageData[0]);
   \   0000001E   0x....             LDR.N    R0,??DataTable7_16
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF200 0x0005      ADDW     R0,R0,#+5
   \   00000026   0x0004             MOVS     R4,R0
    411              for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??AntReadData_1: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2808             CMP      R0,#+8
   \   0000002E   0xDA06             BGE.N    ??AntReadData_2
    412              {
    413                G_au8AntApiCurrentData[i] = *(pu8Parser + i);
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5D01             LDRB     R1,[R0, R4]
   \   00000034   0x....             LDR.N    R2,??DataTable7_19
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x5481             STRB     R1,[R0, R2]
    414              }
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xE7F5             B.N      ??AntReadData_1
    415              AntDeQueueApplicationMessage();
   \                     ??AntReadData_2: (+1)
   \   0000003E   0x.... 0x....      BL       AntDeQueueApplicationMessage
    416              
    417              return TRUE;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE000             B.N      ??AntReadData_3
    418            }
    419            
    420            /* Otherwise return FALSE and do not touch the current data array */
    421            return FALSE;
   \                     ??AntReadData_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??AntReadData_3: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    422            
    423          } /* end AntReadData() */

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     G_stAntSetupData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     G_au8AntMessageSetup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     ??au8AntBroadcastDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x........         DC32     ??au8AntAckDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_17:
   \   00000000   0x........         DC32     G_u32AntApiCurrentDataTimeStamp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_18:
   \   00000000   0x........         DC32     G_eAntApiCurrentMessageClass

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_19:
   \   00000000   0x........         DC32     G_au8AntApiCurrentData

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x03 0x42          DC8 3, 66, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x05 0x51          DC8 5, 81, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x03 0x43          DC8 3, 67, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x02 0x45          DC8 2, 69, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x02 0x47          DC8 2, 71, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x01 0x4B          DC8 1, 75, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x01 0x4C          DC8 1, 76, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x01 0x41          DC8 1, 65, 0, 0
   \              0x00 0x00    
    424          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   AntChannelConfig
        56   -> AntCalculateTxChecksum
        56   -> AntExpectResponse
        56   -> AntTxMessage
        56   -> DebugPrintf
       8   AntCloseChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       8   AntOpenChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       8   AntQueueAcknowledgedMessage
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       8   AntQueueBroadcastMessage
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
       0   AntRadioStatus
       8   AntReadData
         8   -> AntDeQueueApplicationMessage
       8   AntUnassignChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       4  ?_5
       4  ?_6
       4  ?_7
     426  AntChannelConfig
      48  AntCloseChannel
      48  AntOpenChannel
      54  AntQueueAcknowledgedMessage
      54  AntQueueBroadcastMessage
      40  AntRadioStatus
      74  AntReadData
      48  AntUnassignChannel
       8  G_au8AntApiCurrentData
       1  G_eAntApiCurrentMessageClass
       4  G_u32AntApiCurrentDataTimeStamp
      12  au8AntAckDataMessage
      12  au8AntBroadcastDataMessage

 
  13 bytes in section .bss
  24 bytes in section .data
  52 bytes in section .rodata
 872 bytes in section .text
 
 872 bytes of CODE  memory
  52 bytes of CONST memory
  37 bytes of DATA  memory

Errors: none
Warnings: none
