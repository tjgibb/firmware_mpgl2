###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Apr/2016  18:53:21
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\application\user_app.c
#    Command line =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\application\user_app.c
#        --preprocess=cl
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -lC
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -o
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\ -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\bsp\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\drivers\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\application\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\libraries\captouch\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\user_app.lst
#    Object file  =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\Obj\user_app.o
#
###############################################################################

C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\application\user_app.c
      1          /**********************************************************************************************************************
      2          File: user_app.c                                                                
      3          
      4          ----------------------------------------------------------------------------------------------------------------------
      5          To start a new task using this user_app as a template:
      6           1. Copy both user_app.c and user_app.h to the Application directory
      7           2. Rename the files yournewtaskname.c and yournewtaskname.h
      8           3. Add yournewtaskname.c and yournewtaskname.h to the Application Include and Source groups in the IAR project
      9           4. Use ctrl-h (make sure "Match Case" is checked) to find and replace all instances of "user_app" with "yournewtaskname"
     10           5. Use ctrl-h to find and replace all instances of "UserApp" with "YourNewTaskName"
     11           6. Use ctrl-h to find and replace all instances of "USER_APP" with "YOUR_NEW_TASK_NAME"
     12           7. Add a call to YourNewTaskNameInitialize() in the init section of main
     13           8. Add a call to YourNewTaskNameRunActiveState() in the Super Loop section of main
     14           9. Update yournewtaskname.h per the instructions at the top of yournewtaskname.h
     15          10. Delete this text (between the dashed lines) and update the Description below to describe your task
     16          ----------------------------------------------------------------------------------------------------------------------
     17          
     18          Description:
     19          This is a user_app.c file template 
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          API:
     23          
     24          Public functions:
     25          
     26          
     27          Protected System functions:
     28          void UserAppInitialize(void)
     29          Runs required initialzation for the task.  Should only be called once in main init section.
     30          
     31          void UserAppRunActiveState(void)
     32          Runs current task state.  Should only be called once in main loop.
     33          
     34          
     35          **********************************************************************************************************************/
     36          
     37          #include "configuration.h"
     38          
     39          /***********************************************************************************************************************
     40          Global variable definitions with scope across entire project.
     41          All Global variable names shall start with "G_"
     42          ***********************************************************************************************************************/
     43          /* New variables */

   \                                 In section .bss, align 4
     44          volatile u32 G_u32UserAppFlags;                       /* Global state flags */
   \                     G_u32UserAppFlags:
   \   00000000                      DS8 4
     45          
     46          
     47          /*--------------------------------------------------------------------------------------------------------------------*/
     48          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     49          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     50          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     51          
     52          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     53          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     54          
     55          extern AntSetupDataType G_stAntSetupData; /* From ant.c */
     56          
     57          extern u32 G_u32AntApiCurrentDataTimeStamp; /* From ant_api.c */
     58          extern AntApplicationMessageType G_eAntApiCurrentMessageClass; /* From ant_api.c */
     59          extern u8 G_au8AntApiCurrentData[ANT_APPLICATION_MESSAGE_BYTES]; /* From ant_api.c */
     60          
     61          /***********************************************************************************************************************
     62          Global variable definitions with scope limited to this local application.
     63          Variable names shall start with "UserApp_" and be declared as static.
     64          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     65          static fnCode_type UserApp_StateMachine;            /* The state machine function pointer */
   \                     UserApp_StateMachine:
   \   00000000                      DS8 4
     66          static u32 UserApp_u32Timeout;                      /* Timeout counter used across states */

   \                                 In section .data, align 4
     67          static char morseBinArray[26][6] = {MORSE_A,MORSE_B,MORSE_C,MORSE_D,MORSE_E,MORSE_F,MORSE_G,MORSE_H,MORSE_I,
   \                     morseBinArray:
   \   00000000   0x64 0x6D          DC8 "dm"
   \              0x00         
   \   00000003   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000006   0x6D 0x64          DC8 "mddd"
   \              0x64 0x64    
   \              0x00         
   \   0000000B   0x00               DC8 0
   \   0000000C   0x6D 0x64          DC8 "mdmd"
   \              0x6D 0x64    
   \              0x00         
   \   00000011   0x00               DC8 0
   \   00000012   0x6D 0x64          DC8 "mdd"
   \              0x64 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
   \   00000018   0x64 0x00          DC8 "d"
   \   0000001A   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001E   0x64 0x64          DC8 "ddmd"
   \              0x6D 0x64    
   \              0x00         
   \   00000023   0x00               DC8 0
   \   00000024   0x6D 0x6D          DC8 "mmd"
   \              0x64 0x00    
   \   00000028   0x00 0x00          DC8 0, 0
   \   0000002A   0x64 0x64          DC8 "dddd"
   \              0x64 0x64    
   \              0x00         
   \   0000002F   0x00               DC8 0
   \   00000030   0x64 0x64          DC8 "dd"
   \              0x00         
   \   00000033   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000036   0x64 0x6D          DC8 "dmmm"
   \              0x6D 0x6D    
   \              0x00         
   \   0000003B   0x00               DC8 0
   \   0000003C   0x6D 0x64          DC8 "mdm"
   \              0x6D 0x00    
   \   00000040   0x00 0x00          DC8 0, 0
   \   00000042   0x64 0x6D          DC8 "dmdd"
   \              0x64 0x64    
   \              0x00         
   \   00000047   0x00               DC8 0
   \   00000048   0x6D 0x6D          DC8 "mm"
   \              0x00         
   \   0000004B   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   0000004E   0x6D 0x64          DC8 "md"
   \              0x00         
   \   00000051   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000054   0x6D 0x6D          DC8 "mmm"
   \              0x6D 0x00    
   \   00000058   0x00 0x00          DC8 0, 0
   \   0000005A   0x64 0x6D          DC8 "dmmd"
   \              0x6D 0x64    
   \              0x00         
   \   0000005F   0x00               DC8 0
   \   00000060   0x6D 0x6D          DC8 "mmdm"
   \              0x64 0x6D    
   \              0x00         
   \   00000065   0x00               DC8 0
   \   00000066   0x64 0x6D          DC8 "dmd"
   \              0x64 0x00    
   \   0000006A   0x00 0x00          DC8 0, 0
   \   0000006C   0x64 0x64          DC8 "ddd"
   \              0x64 0x00    
   \   00000070   0x00 0x00          DC8 0, 0
   \   00000072   0x6D 0x00          DC8 "m"
   \   00000074   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000078   0x64 0x64          DC8 "ddm"
   \              0x6D 0x00    
   \   0000007C   0x00 0x00          DC8 0, 0
   \   0000007E   0x64 0x64          DC8 "dddm"
   \              0x64 0x6D    
   \              0x00         
   \   00000083   0x00               DC8 0
   \   00000084   0x64 0x6D          DC8 "dmm"
   \              0x6D 0x00    
   \   00000088   0x00 0x00          DC8 0, 0
   \   0000008A   0x6D 0x64          DC8 "mddm"
   \              0x64 0x6D    
   \              0x00         
   \   0000008F   0x00               DC8 0
   \   00000090   0x6D 0x64          DC8 "mdmm"
   \              0x6D 0x6D    
   \              0x00         
   \   00000095   0x00               DC8 0
   \   00000096   0x6D 0x6D          DC8 "mmdd"
   \              0x64 0x64    
   \              0x00         
   \   0000009B   0x00               DC8 0
     68          MORSE_J,MORSE_K,MORSE_L,MORSE_M,MORSE_N,MORSE_O,MORSE_P,MORSE_Q,MORSE_R,MORSE_S,MORSE_T,MORSE_U,MORSE_V,MORSE_W,MORSE_X,MORSE_Y,MORSE_Z};

   \                                 In section .data, align 4
     69          static char morseCharArray[26] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   \                     morseCharArray:
   \   00000000   0x41 0x42          DC8 41H, 42H, 43H, 44H, 45H, 46H, 47H, 48H
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x47 0x48    
   \   00000008   0x49 0x4A          DC8 49H, 4AH, 4BH, 4CH, 4DH, 4EH, 4FH, 50H
   \              0x4B 0x4C    
   \              0x4D 0x4E    
   \              0x4F 0x50    
   \   00000010   0x51 0x52          DC8 51H, 52H, 53H, 54H, 55H, 56H, 57H, 58H
   \              0x53 0x54    
   \              0x55 0x56    
   \              0x57 0x58    
   \   00000018   0x59 0x5A          DC8 59H, 5AH
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .bss, align 4
     70          static char messageArray[25] = "";
   \                     messageArray:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     71          static char messageArray2[25] = "";
   \                     messageArray2:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     72          static char messageArray3[25] = "";
   \                     messageArray3:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     73          static char messageArray4[25] = "";
   \                     messageArray4:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     74          static char messageArray5[25] = "";
   \                     messageArray5:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     75          static char messageArray6[25] = "";
   \                     messageArray6:
   \   00000000                      DS8 28

   \                                 In section .bss, align 1
     76          static u8 messageCharCount;
   \                     messageCharCount:
   \   00000000                      DS8 1
     77          
     78          /**********************************************************************************************************************
     79          Function Definitions
     80          **********************************************************************************************************************/
     81          
     82          /*--------------------------------------------------------------------------------------------------------------------*/
     83          /* Public functions                                                                                                   */
     84          /*--------------------------------------------------------------------------------------------------------------------*/
     85          

   \                                 In section .text, align 2, keep-with-next
     86          void addSpace(void)
     87          {
   \                     addSpace: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     88            char spaceString[2] = " ";
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000008   0x8800             LDRH     R0,[R0, #+0]
   \   0000000A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     89            
     90            if(messageCharCount < 22) //First row of Chars
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2816             CMP      R0,#+22
   \   00000016   0xDA0E             BGE.N    ??addSpace_0
     91            {
     92            strcat(messageArray, spaceString);
   \   00000018   0xA900             ADD      R1,SP,#+0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   0000001E   0x.... 0x....      BL       strcat
     93            PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE0,LCD_LEFT_MOST_COLUMN};
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x9006             STR      R0,[SP, #+24]
     94            LcdLoadString(messageArray, LCD_FONT_SMALL, &morseLocation);
                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   0000002A   0xAA06             ADD      R2,SP,#+24
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000032   0x.... 0x....      BL       LcdLoadString
     95            }
     96            
     97            if((messageCharCount >= 22) && (messageCharCount < 43))
   \                     ??addSpace_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2816             CMP      R0,#+22
   \   0000003E   0xDB13             BLT.N    ??addSpace_1
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x282B             CMP      R0,#+43
   \   00000048   0xDA0E             BGE.N    ??addSpace_1
     98            {
     99            strcat(messageArray2, spaceString);
   \   0000004A   0xA900             ADD      R1,SP,#+0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000050   0x.... 0x....      BL       strcat
    100            PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE1,LCD_LEFT_MOST_COLUMN};
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x9005             STR      R0,[SP, #+20]
    101            LcdLoadString(messageArray2, LCD_FONT_SMALL, &morseLocation);
                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   0000005C   0xAA05             ADD      R2,SP,#+20
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000064   0x.... 0x....      BL       LcdLoadString
    102            }
    103            
    104            if((messageCharCount >= 43) && (messageCharCount < 64))
   \                     ??addSpace_1: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x282B             CMP      R0,#+43
   \   00000070   0xDB13             BLT.N    ??addSpace_2
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2840             CMP      R0,#+64
   \   0000007A   0xDA0E             BGE.N    ??addSpace_2
    105            {
    106            strcat(messageArray3, spaceString);
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000082   0x.... 0x....      BL       strcat
    107            PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE2,LCD_LEFT_MOST_COLUMN};
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x9004             STR      R0,[SP, #+16]
    108            LcdLoadString(messageArray3, LCD_FONT_SMALL, &morseLocation);   
                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   0000008E   0xAA04             ADD      R2,SP,#+16
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000096   0x.... 0x....      BL       LcdLoadString
    109            }
    110            
    111            if((messageCharCount >= 64) && (messageCharCount < 85))
   \                     ??addSpace_2: (+1)
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x2840             CMP      R0,#+64
   \   000000A2   0xDB13             BLT.N    ??addSpace_3
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x2855             CMP      R0,#+85
   \   000000AC   0xDA0E             BGE.N    ??addSpace_3
    112            {
    113            strcat(messageArray4, spaceString);
   \   000000AE   0xA900             ADD      R1,SP,#+0
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000B4   0x.... 0x....      BL       strcat
    114            PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE3,LCD_LEFT_MOST_COLUMN};
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable4_9
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x9003             STR      R0,[SP, #+12]
    115            LcdLoadString(messageArray4, LCD_FONT_SMALL, &morseLocation);   
                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   000000C0   0xAA03             ADD      R2,SP,#+12
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000C8   0x.... 0x....      BL       LcdLoadString
    116            }
    117           if((messageCharCount >= 85) && (messageCharCount < 106))
   \                     ??addSpace_3: (+1)
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x2855             CMP      R0,#+85
   \   000000D4   0xDB13             BLT.N    ??addSpace_4
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x286A             CMP      R0,#+106
   \   000000DE   0xDA0E             BGE.N    ??addSpace_4
    118           {
    119            strcat(messageArray5, spaceString);
   \   000000E0   0xA900             ADD      R1,SP,#+0
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable4_10
   \   000000E6   0x.... 0x....      BL       strcat
    120            PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE4,LCD_LEFT_MOST_COLUMN};
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable4_11
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0x9002             STR      R0,[SP, #+8]
    121            LcdLoadString(messageArray5, LCD_FONT_SMALL, &morseLocation);  
                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   000000F2   0xAA02             ADD      R2,SP,#+8
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable4_10
   \   000000FA   0x.... 0x....      BL       LcdLoadString
    122           }
    123            
    124           if((messageCharCount >= 106) && (messageCharCount < 127))
   \                     ??addSpace_4: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0x286A             CMP      R0,#+106
   \   00000106   0xDB13             BLT.N    ??addSpace_5
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000010C   0x7800             LDRB     R0,[R0, #+0]
   \   0000010E   0x287F             CMP      R0,#+127
   \   00000110   0xDA0E             BGE.N    ??addSpace_5
    125           {
    126            strcat(messageArray6, spaceString);
   \   00000112   0xA900             ADD      R1,SP,#+0
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable4_12
   \   00000118   0x.... 0x....      BL       strcat
    127            PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE5,LCD_LEFT_MOST_COLUMN};
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable4_13
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x9001             STR      R0,[SP, #+4]
    128            LcdLoadString(messageArray6, LCD_FONT_SMALL, &morseLocation); 
                                 ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   00000124   0xAA01             ADD      R2,SP,#+4
   \   00000126   0x2100             MOVS     R1,#+0
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable4_12
   \   0000012C   0x.... 0x....      BL       LcdLoadString
    129           }
    130           
    131          messageCharCount++;
   \                     ??addSpace_5: (+1)
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x1C40             ADDS     R0,R0,#+1
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable4_1
   \   0000013C   0x7008             STRB     R0,[R1, #+0]
    132            
    133          }
   \   0000013E   0xB007             ADD      SP,SP,#+28
   \   00000140   0xBD00             POP      {PC}             ;; return
    134          
    135          

   \                                 In section .text, align 2, keep-with-next
    136          void processCharacter(u32* array, u8 count)
    137          {
   \                     processCharacter: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    138          
    139          u8 i = 0;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    140          u8 charcount = count / 2; /* The nature of entry means that each dot or dash involves 2 array addresses.
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xFB95 0xF6F0      SDIV     R6,R5,R0
    141                                          Dividing by 2 will help in iteration.*/
    142          messageCharCount++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable4_1
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    143          
    144          u32 pulseTime = 0;
   \   00000024   0x2700             MOVS     R7,#+0
    145          char charArray[6] = "";
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0xC006             STM      R0!,{R1,R2}
   \   0000002E   0x3808             SUBS     R0,R0,#+8
    146          char tempCharString[2] = "";
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    147          
    148          
    149          for(i = 0; i < charcount; i++)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4680             MOV      R8,R0
   \                     ??processCharacter_0: (+1)
   \   0000003A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x45B0             CMP      R8,R6
   \   00000042   0xD21E             BCS.N    ??processCharacter_1
    150          {
    151            
    152            pulseTime = array[(2*i) + 1] - array[2*i];
   \   00000044   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000048   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   0000004C   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000050   0x6840             LDR      R0,[R0, #+4]
   \   00000052   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000056   0xF854 0x1038      LDR      R1,[R4, R8, LSL #+3]
   \   0000005A   0x1A40             SUBS     R0,R0,R1
   \   0000005C   0x0007             MOVS     R7,R0
    153            if(pulseTime < DOT_TIME)
   \   0000005E   0x2FF4             CMP      R7,#+244
   \   00000060   0xD206             BCS.N    ??processCharacter_2
    154              charArray[i] = 'd';
   \   00000062   0x2064             MOVS     R0,#+100
   \   00000064   0xA901             ADD      R1,SP,#+4
   \   00000066   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006A   0xF808 0x0001      STRB     R0,[R8, R1]
   \   0000006E   0xE005             B.N      ??processCharacter_3
    155            else
    156              charArray[i] = 'm';
   \                     ??processCharacter_2: (+1)
   \   00000070   0x206D             MOVS     R0,#+109
   \   00000072   0xA901             ADD      R1,SP,#+4
   \   00000074   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000078   0xF808 0x0001      STRB     R0,[R8, R1]
    157          }
   \                     ??processCharacter_3: (+1)
   \   0000007C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000080   0xE7DB             B.N      ??processCharacter_0
    158          charArray[i] = '\0';
   \                     ??processCharacter_1: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xA901             ADD      R1,SP,#+4
   \   00000086   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000008A   0xF808 0x0001      STRB     R0,[R8, R1]
    159          if(messageCharCount < 22) //First row of Chars
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0x2816             CMP      R0,#+22
   \   00000096   0xDA2A             BGE.N    ??processCharacter_4
    160          {
    161            for(int j = 0; j < 26; j++)
   \   00000098   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??processCharacter_5: (+1)
   \   0000009C   0xF1B9 0x0F1A      CMP      R9,#+26
   \   000000A0   0xDA1B             BGE.N    ??processCharacter_6
    162          {
    163            if(!strcmp(charArray,morseBinArray[j]))
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable4_14
   \   000000A6   0x2106             MOVS     R1,#+6
   \   000000A8   0xFB01 0x0109      MLA      R1,R1,R9,R0
   \   000000AC   0xA801             ADD      R0,SP,#+4
   \   000000AE   0x.... 0x....      BL       strcmp
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD10E             BNE.N    ??processCharacter_7
    164            {
    165              tempCharString[0] = morseCharArray[j]; /*Build a temporary string using the char from morsebin. I want to use strcat to build
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable4_15
   \   000000BA   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000000BE   0xF88D 0x0000      STRB     R0,[SP, #+0]
    166                                                    message array, but need to build a real string with a null character to do it. I want my 
    167                                                    message array to be persistent, rather than replacing letter 0 each time. I could have a constant
    168                                                    char value that increments with each char in the array, but this seems easier to me*/
    169              tempCharString[1] = '\0';
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF88D 0x0001      STRB     R0,[SP, #+1]
    170              strcat(messageArray, tempCharString);
   \   000000C8   0xA900             ADD      R1,SP,#+0
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   000000CE   0x.... 0x....      BL       strcat
    171              break;
   \   000000D2   0xE002             B.N      ??processCharacter_6
    172            }
    173          }
   \                     ??processCharacter_7: (+1)
   \   000000D4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000D8   0xE7E0             B.N      ??processCharacter_5
    174          
    175          PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE0,LCD_LEFT_MOST_COLUMN}; 
   \                     ??processCharacter_6: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable4_16
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x9008             STR      R0,[SP, #+32]
    176          LcdLoadString(messageArray, LCD_FONT_SMALL, &morseLocation);
                               ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   000000E2   0xAA08             ADD      R2,SP,#+32
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   000000EA   0x.... 0x....      BL       LcdLoadString
    177            
    178          }
    179          
    180          if((messageCharCount >= 22) && (messageCharCount < 43)) //Second row of chars
   \                     ??processCharacter_4: (+1)
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x2816             CMP      R0,#+22
   \   000000F6   0xDB2C             BLT.N    ??processCharacter_8
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x282B             CMP      R0,#+43
   \   00000100   0xDA27             BGE.N    ??processCharacter_8
    181          {
    182            for(int j = 0; j < 26; j++)
   \   00000102   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??processCharacter_9: (+1)
   \   00000106   0xF1B9 0x0F1A      CMP      R9,#+26
   \   0000010A   0xDA1A             BGE.N    ??processCharacter_10
    183          {
    184            if(!strcmp(charArray,morseBinArray[j]))
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable4_14
   \   00000110   0x2106             MOVS     R1,#+6
   \   00000112   0xFB01 0x0109      MLA      R1,R1,R9,R0
   \   00000116   0xA801             ADD      R0,SP,#+4
   \   00000118   0x.... 0x....      BL       strcmp
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD10D             BNE.N    ??processCharacter_11
    185            {
    186              tempCharString[0] = morseCharArray[j]; /*Build a temporary string using the char from morsebin. I want to use strcat to build
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable4_15
   \   00000124   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   00000128   0xF88D 0x0000      STRB     R0,[SP, #+0]
    187                                                    message array, but need to build a real string with a null character to do it. I want my 
    188                                                    message array to be persistent, rather than replacing letter 0 each time. I could have a constant
    189                                                    char value that increments with each char in the array, but this seems easier to me*/
    190              tempCharString[1] = '\0';
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    191              strcat(messageArray2, tempCharString);
   \   00000132   0xA900             ADD      R1,SP,#+0
   \   00000134   0x....             LDR.N    R0,??DataTable4_4
   \   00000136   0x.... 0x....      BL       strcat
    192              break;
   \   0000013A   0xE002             B.N      ??processCharacter_10
    193            }
    194          }
   \                     ??processCharacter_11: (+1)
   \   0000013C   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000140   0xE7E1             B.N      ??processCharacter_9
    195          
    196          PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE1,LCD_LEFT_MOST_COLUMN};
   \                     ??processCharacter_10: (+1)
   \   00000142   0x....             LDR.N    R0,??DataTable4_17
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0x9007             STR      R0,[SP, #+28]
    197          LcdLoadString(messageArray2, LCD_FONT_SMALL, &morseLocation);
                               ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   00000148   0xAA07             ADD      R2,SP,#+28
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x....             LDR.N    R0,??DataTable4_4
   \   0000014E   0x.... 0x....      BL       LcdLoadString
    198            
    199          }
    200          
    201          if((messageCharCount >= 43) && (messageCharCount < 64)) //third row of chars
   \                     ??processCharacter_8: (+1)
   \   00000152   0x....             LDR.N    R0,??DataTable4_1
   \   00000154   0x7800             LDRB     R0,[R0, #+0]
   \   00000156   0x282B             CMP      R0,#+43
   \   00000158   0xDB29             BLT.N    ??processCharacter_12
   \   0000015A   0x....             LDR.N    R0,??DataTable4_1
   \   0000015C   0x7800             LDRB     R0,[R0, #+0]
   \   0000015E   0x2840             CMP      R0,#+64
   \   00000160   0xDA25             BGE.N    ??processCharacter_12
    202          {
    203            for(int j = 0; j < 26; j++)
   \   00000162   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??processCharacter_13: (+1)
   \   00000166   0xF1B9 0x0F1A      CMP      R9,#+26
   \   0000016A   0xDA18             BGE.N    ??processCharacter_14
    204          {
    205            if(!strcmp(charArray,morseBinArray[j]))
   \   0000016C   0x....             LDR.N    R0,??DataTable4_14
   \   0000016E   0x2106             MOVS     R1,#+6
   \   00000170   0xFB01 0x0109      MLA      R1,R1,R9,R0
   \   00000174   0xA801             ADD      R0,SP,#+4
   \   00000176   0x.... 0x....      BL       strcmp
   \   0000017A   0x2800             CMP      R0,#+0
   \   0000017C   0xD10C             BNE.N    ??processCharacter_15
    206            {
    207              tempCharString[0] = morseCharArray[j]; /*Build a temporary string using the char from morsebin. I want to use strcat to build
   \   0000017E   0x....             LDR.N    R0,??DataTable4_15
   \   00000180   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   00000184   0xF88D 0x0000      STRB     R0,[SP, #+0]
    208                                                    message array, but need to build a real string with a null character to do it. I want my 
    209                                                    message array to be persistent, rather than replacing letter 0 each time. I could have a constant
    210                                                    char value that increments with each char in the array, but this seems easier to me*/
    211              tempCharString[1] = '\0';
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    212              strcat(messageArray3, tempCharString);
   \   0000018E   0xA900             ADD      R1,SP,#+0
   \   00000190   0x....             LDR.N    R0,??DataTable4_6
   \   00000192   0x.... 0x....      BL       strcat
    213              break;
   \   00000196   0xE002             B.N      ??processCharacter_14
    214            }
    215          }
   \                     ??processCharacter_15: (+1)
   \   00000198   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000019C   0xE7E3             B.N      ??processCharacter_13
    216          
    217          PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE2,LCD_LEFT_MOST_COLUMN};
   \                     ??processCharacter_14: (+1)
   \   0000019E   0x....             LDR.N    R0,??DataTable4_18
   \   000001A0   0x6800             LDR      R0,[R0, #+0]
   \   000001A2   0x9006             STR      R0,[SP, #+24]
    218          LcdLoadString(messageArray3, LCD_FONT_SMALL, &morseLocation);
                               ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   000001A4   0xAA06             ADD      R2,SP,#+24
   \   000001A6   0x2100             MOVS     R1,#+0
   \   000001A8   0x....             LDR.N    R0,??DataTable4_6
   \   000001AA   0x.... 0x....      BL       LcdLoadString
    219            
    220          }
    221          
    222          if((messageCharCount >= 64) && (messageCharCount < 85)) //fourth row of chars
   \                     ??processCharacter_12: (+1)
   \   000001AE   0x....             LDR.N    R0,??DataTable4_1
   \   000001B0   0x7800             LDRB     R0,[R0, #+0]
   \   000001B2   0x2840             CMP      R0,#+64
   \   000001B4   0xDB29             BLT.N    ??processCharacter_16
   \   000001B6   0x....             LDR.N    R0,??DataTable4_1
   \   000001B8   0x7800             LDRB     R0,[R0, #+0]
   \   000001BA   0x2855             CMP      R0,#+85
   \   000001BC   0xDA25             BGE.N    ??processCharacter_16
    223          {
    224            for(int j = 0; j < 26; j++)
   \   000001BE   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??processCharacter_17: (+1)
   \   000001C2   0xF1B9 0x0F1A      CMP      R9,#+26
   \   000001C6   0xDA18             BGE.N    ??processCharacter_18
    225          {
    226            if(!strcmp(charArray,morseBinArray[j]))
   \   000001C8   0x....             LDR.N    R0,??DataTable4_14
   \   000001CA   0x2106             MOVS     R1,#+6
   \   000001CC   0xFB01 0x0109      MLA      R1,R1,R9,R0
   \   000001D0   0xA801             ADD      R0,SP,#+4
   \   000001D2   0x.... 0x....      BL       strcmp
   \   000001D6   0x2800             CMP      R0,#+0
   \   000001D8   0xD10C             BNE.N    ??processCharacter_19
    227            {
    228              tempCharString[0] = morseCharArray[j]; /*Build a temporary string using the char from morsebin. I want to use strcat to build
   \   000001DA   0x....             LDR.N    R0,??DataTable4_15
   \   000001DC   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000001E0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    229                                                    message array, but need to build a real string with a null character to do it. I want my 
    230                                                    message array to be persistent, rather than replacing letter 0 each time. I could have a constant
    231                                                    char value that increments with each char in the array, but this seems easier to me*/
    232              tempCharString[1] = '\0';
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xF88D 0x0001      STRB     R0,[SP, #+1]
    233              strcat(messageArray4, tempCharString);
   \   000001EA   0xA900             ADD      R1,SP,#+0
   \   000001EC   0x....             LDR.N    R0,??DataTable4_8
   \   000001EE   0x.... 0x....      BL       strcat
    234              break;
   \   000001F2   0xE002             B.N      ??processCharacter_18
    235            }
    236          }
   \                     ??processCharacter_19: (+1)
   \   000001F4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000001F8   0xE7E3             B.N      ??processCharacter_17
    237          
    238          PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE3,LCD_LEFT_MOST_COLUMN};
   \                     ??processCharacter_18: (+1)
   \   000001FA   0x....             LDR.N    R0,??DataTable4_19
   \   000001FC   0x6800             LDR      R0,[R0, #+0]
   \   000001FE   0x9005             STR      R0,[SP, #+20]
    239          LcdLoadString(messageArray4, LCD_FONT_SMALL, &morseLocation);
                               ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   00000200   0xAA05             ADD      R2,SP,#+20
   \   00000202   0x2100             MOVS     R1,#+0
   \   00000204   0x....             LDR.N    R0,??DataTable4_8
   \   00000206   0x.... 0x....      BL       LcdLoadString
    240            
    241          }
    242          
    243          if((messageCharCount >= 85) && (messageCharCount < 106)) //fifth row of chars
   \                     ??processCharacter_16: (+1)
   \   0000020A   0x....             LDR.N    R0,??DataTable4_1
   \   0000020C   0x7800             LDRB     R0,[R0, #+0]
   \   0000020E   0x2855             CMP      R0,#+85
   \   00000210   0xDB29             BLT.N    ??processCharacter_20
   \   00000212   0x....             LDR.N    R0,??DataTable4_1
   \   00000214   0x7800             LDRB     R0,[R0, #+0]
   \   00000216   0x286A             CMP      R0,#+106
   \   00000218   0xDA25             BGE.N    ??processCharacter_20
    244          {
    245            for(int j = 0; j < 26; j++)
   \   0000021A   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??processCharacter_21: (+1)
   \   0000021E   0xF1B9 0x0F1A      CMP      R9,#+26
   \   00000222   0xDA18             BGE.N    ??processCharacter_22
    246          {
    247            if(!strcmp(charArray,morseBinArray[j]))
   \   00000224   0x....             LDR.N    R0,??DataTable4_14
   \   00000226   0x2106             MOVS     R1,#+6
   \   00000228   0xFB01 0x0109      MLA      R1,R1,R9,R0
   \   0000022C   0xA801             ADD      R0,SP,#+4
   \   0000022E   0x.... 0x....      BL       strcmp
   \   00000232   0x2800             CMP      R0,#+0
   \   00000234   0xD10C             BNE.N    ??processCharacter_23
    248            {
    249              tempCharString[0] = morseCharArray[j]; /*Build a temporary string using the char from morsebin. I want to use strcat to build
   \   00000236   0x....             LDR.N    R0,??DataTable4_15
   \   00000238   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   0000023C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    250                                                    message array, but need to build a real string with a null character to do it. I want my 
    251                                                    message array to be persistent, rather than replacing letter 0 each time. I could have a constant
    252                                                    char value that increments with each char in the array, but this seems easier to me*/
    253              tempCharString[1] = '\0';
   \   00000240   0x2000             MOVS     R0,#+0
   \   00000242   0xF88D 0x0001      STRB     R0,[SP, #+1]
    254              strcat(messageArray5, tempCharString);
   \   00000246   0xA900             ADD      R1,SP,#+0
   \   00000248   0x....             LDR.N    R0,??DataTable4_10
   \   0000024A   0x.... 0x....      BL       strcat
    255              break;
   \   0000024E   0xE002             B.N      ??processCharacter_22
    256            }
    257          }
   \                     ??processCharacter_23: (+1)
   \   00000250   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000254   0xE7E3             B.N      ??processCharacter_21
    258          
    259          PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE4,LCD_LEFT_MOST_COLUMN};
   \                     ??processCharacter_22: (+1)
   \   00000256   0x....             LDR.N    R0,??DataTable4_20
   \   00000258   0x6800             LDR      R0,[R0, #+0]
   \   0000025A   0x9004             STR      R0,[SP, #+16]
    260          LcdLoadString(messageArray5, LCD_FONT_SMALL, &morseLocation);
                               ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   0000025C   0xAA04             ADD      R2,SP,#+16
   \   0000025E   0x2100             MOVS     R1,#+0
   \   00000260   0x....             LDR.N    R0,??DataTable4_10
   \   00000262   0x.... 0x....      BL       LcdLoadString
    261            
    262          }
    263          
    264          if((messageCharCount >= 106) && (messageCharCount < 127)) //sixth row of chars
   \                     ??processCharacter_20: (+1)
   \   00000266   0x....             LDR.N    R0,??DataTable4_1
   \   00000268   0x7800             LDRB     R0,[R0, #+0]
   \   0000026A   0x286A             CMP      R0,#+106
   \   0000026C   0xDB29             BLT.N    ??processCharacter_24
   \   0000026E   0x....             LDR.N    R0,??DataTable4_1
   \   00000270   0x7800             LDRB     R0,[R0, #+0]
   \   00000272   0x287F             CMP      R0,#+127
   \   00000274   0xDA25             BGE.N    ??processCharacter_24
    265          {
    266            for(int j = 0; j < 26; j++)
   \   00000276   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??processCharacter_25: (+1)
   \   0000027A   0xF1B9 0x0F1A      CMP      R9,#+26
   \   0000027E   0xDA18             BGE.N    ??processCharacter_26
    267          {
    268            if(!strcmp(charArray,morseBinArray[j]))
   \   00000280   0x....             LDR.N    R0,??DataTable4_14
   \   00000282   0x2106             MOVS     R1,#+6
   \   00000284   0xFB01 0x0109      MLA      R1,R1,R9,R0
   \   00000288   0xA801             ADD      R0,SP,#+4
   \   0000028A   0x.... 0x....      BL       strcmp
   \   0000028E   0x2800             CMP      R0,#+0
   \   00000290   0xD10C             BNE.N    ??processCharacter_27
    269            {
    270              tempCharString[0] = morseCharArray[j]; /*Build a temporary string using the char from morsebin. I want to use strcat to build
   \   00000292   0x....             LDR.N    R0,??DataTable4_15
   \   00000294   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   00000298   0xF88D 0x0000      STRB     R0,[SP, #+0]
    271                                                    message array, but need to build a real string with a null character to do it. I want my 
    272                                                    message array to be persistent, rather than replacing letter 0 each time. I could have a constant
    273                                                    char value that increments with each char in the array, but this seems easier to me*/
    274              tempCharString[1] = '\0';
   \   0000029C   0x2000             MOVS     R0,#+0
   \   0000029E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    275              strcat(messageArray6, tempCharString);
   \   000002A2   0xA900             ADD      R1,SP,#+0
   \   000002A4   0x....             LDR.N    R0,??DataTable4_12
   \   000002A6   0x.... 0x....      BL       strcat
    276              break;
   \   000002AA   0xE002             B.N      ??processCharacter_26
    277            }
    278          }
   \                     ??processCharacter_27: (+1)
   \   000002AC   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000002B0   0xE7E3             B.N      ??processCharacter_25
    279          
    280          PixelAddressType morseLocation = {LCD_SMALL_FONT_LINE5,LCD_LEFT_MOST_COLUMN};
   \                     ??processCharacter_26: (+1)
   \   000002B2   0x....             LDR.N    R0,??DataTable4_21
   \   000002B4   0x6800             LDR      R0,[R0, #+0]
   \   000002B6   0x9003             STR      R0,[SP, #+12]
    281          LcdLoadString(messageArray6, LCD_FONT_SMALL, &morseLocation);
                               ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "unsigned char const *"
   \   000002B8   0xAA03             ADD      R2,SP,#+12
   \   000002BA   0x2100             MOVS     R1,#+0
   \   000002BC   0x....             LDR.N    R0,??DataTable4_12
   \   000002BE   0x.... 0x....      BL       LcdLoadString
    282            
    283          }
    284          
    285          return;
   \                     ??processCharacter_24: (+1)
   \   000002C2   0xB009             ADD      SP,SP,#+36
   \   000002C4   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    286            
    287          }
    288          
    289          
    290          /*--------------------------------------------------------------------------------------------------------------------*/
    291          /* Protected functions                                                                                                */
    292          /*--------------------------------------------------------------------------------------------------------------------*/
    293          
    294          /*--------------------------------------------------------------------------------------------------------------------
    295          Function: UserAppInitialize
    296          
    297          Description:
    298          Initializes the State Machine and its variables.
    299          
    300          Requires:
    301            -
    302          
    303          Promises:
    304            - 
    305          */

   \                                 In section .text, align 2, keep-with-next
    306          void UserAppInitialize(void)
    307          {
   \                     UserAppInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    308          G_stAntSetupData.AntChannel = ANT_CHANNEL_USERAPP;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable4_22
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    309          G_stAntSetupData.AntSerialLo = ANT_SERIAL_LO_USERAPP;
   \   00000008   0x2034             MOVS     R0,#+52
   \   0000000A   0x....             LDR.N    R1,??DataTable4_22
   \   0000000C   0x70C8             STRB     R0,[R1, #+3]
    310          G_stAntSetupData.AntSerialHi = ANT_SERIAL_HI_USERAPP;
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0x....             LDR.N    R1,??DataTable4_22
   \   00000012   0x7108             STRB     R0,[R1, #+4]
    311          G_stAntSetupData.AntDeviceType = ANT_DEVICE_TYPE_USERAPP;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable4_22
   \   00000018   0x7148             STRB     R0,[R1, #+5]
    312          G_stAntSetupData.AntTransmissionType = ANT_TRANSMISSION_TYPE_USERAPP;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable4_22
   \   0000001E   0x7188             STRB     R0,[R1, #+6]
    313          G_stAntSetupData.AntChannelPeriodLo = ANT_CHANNEL_PERIOD_LO_USERAPP;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable4_22
   \   00000024   0x71C8             STRB     R0,[R1, #+7]
    314          G_stAntSetupData.AntChannelPeriodHi = ANT_CHANNEL_PERIOD_HI_USERAPP;
   \   00000026   0x2020             MOVS     R0,#+32
   \   00000028   0x....             LDR.N    R1,??DataTable4_22
   \   0000002A   0x7208             STRB     R0,[R1, #+8]
    315          G_stAntSetupData.AntFrequency = ANT_FREQUENCY_USERAPP;
   \   0000002C   0x2032             MOVS     R0,#+50
   \   0000002E   0x....             LDR.N    R1,??DataTable4_22
   \   00000030   0x7248             STRB     R0,[R1, #+9]
    316          G_stAntSetupData.AntTxPower = ANT_TX_POWER_USERAPP;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x....             LDR.N    R1,??DataTable4_22
   \   00000036   0x7288             STRB     R0,[R1, #+10]
    317          LcdClearScreen();
   \   00000038   0x.... 0x....      BL       LcdClearScreen
    318          PWMAudioSetFrequency(BUZZER1, 500);
   \   0000003C   0xF44F 0x71FA      MOV      R1,#+500
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       PWMAudioSetFrequency
    319          
    320          /* If good initialization, set state to Idle */
    321          if( AntChannelConfig(ANT_MASTER) )
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       AntChannelConfig
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD006             BEQ.N    ??UserAppInitialize_0
    322          {
    323          AntOpenChannel();
   \   00000050   0x.... 0x....      BL       AntOpenChannel
    324          UserApp_StateMachine = UserAppSM_Idle;
   \   00000054   0x.... 0x....      ADR.W    R0,UserAppSM_Idle
   \   00000058   0x....             LDR.N    R1,??DataTable4_23
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   \   0000005C   0xE003             B.N      ??UserAppInitialize_1
    325          }
    326          else
    327          {
    328          /* The task isnt properly initialized, so shut it down and dont run */
    329          UserApp_StateMachine = UserAppSM_FailedInit;
   \                     ??UserAppInitialize_0: (+1)
   \   0000005E   0x.... 0x....      ADR.W    R0,UserAppSM_FailedInit
   \   00000062   0x....             LDR.N    R1,??DataTable4_23
   \   00000064   0x6008             STR      R0,[R1, #+0]
    330          }
    331          /*RED2 AND RED3 DO NOT WORK - Q3 AND Q4*/
    332          /*BLUE0 AND BLUE3 DO NOT WORK - Q10 AND Q13*/
    333            /* If good initialization, set state to Idle */
    334            if( 1 /* Add condition for good init */)
    335            {
    336              UserApp_StateMachine = UserAppSM_Idle;
   \                     ??UserAppInitialize_1: (+1)
   \   00000066   0x.... 0x....      ADR.W    R0,UserAppSM_Idle
   \   0000006A   0x....             LDR.N    R1,??DataTable4_23
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    337            }
    338            else
    339            {
    340              /* The task isn't properly initialized, so shut it down and don't run */
    341              UserApp_StateMachine = UserAppSM_FailedInit;
    342            }
    343          
    344          } /* end UserAppInitialize() */
   \   0000006E   0xBD01             POP      {R0,PC}          ;; return
    345          
    346          
    347          /*----------------------------------------------------------------------------------------------------------------------
    348          Function UserAppRunActiveState()
    349          
    350          Description:
    351          Selects and runs one iteration of the current state in the state machine.
    352          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    353          may take 1ms / n to execute.
    354          
    355          Requires:
    356            - State machine function pointer points at current state
    357          
    358          Promises:
    359            - Calls the function to pointed by the state machine function pointer
    360          */

   \                                 In section .text, align 2, keep-with-next
    361          void UserAppRunActiveState(void)
    362          {
   \                     UserAppRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    363            UserApp_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable4_23
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    364          
    365          } /* end UserAppRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    366          
    367          
    368          /*--------------------------------------------------------------------------------------------------------------------*/
    369          /* Private functions                                                                                                  */
    370          /*--------------------------------------------------------------------------------------------------------------------*/
    371          
    372          /* void processCharacter(u32 array[],u8 count) -- I think this is how you do it*/
    373          
    374          /**********************************************************************************************************************
    375          State Machine Function Definitions
    376          **********************************************************************************************************************/
    377          
    378          /*-------------------------------------------------------------------------------------------------------------------*/
    379          /* Wait for a message to be queued */

   \                                 In section .text, align 4, keep-with-next
    380          static void UserAppSM_Idle(void)
    381          {
   \                     UserAppSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    382            static u8 timeCount = 0;
    383            static u32 timeArray[12];
    384            static u8 currentCharFlag = 0;
    385            static u8 entryBegunFlag = 0;
    386            
    387            
    388            if(WasButtonPressed(BUTTON1))
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       WasButtonPressed
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??UserAppSM_Idle_0
    389            {
    390              addSpace();
   \   0000000C   0x.... 0x....      BL       addSpace
    391              ButtonAcknowledge(BUTTON1);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       ButtonAcknowledge
    392            }
    393           
    394          
    395            
    396            if(IsButtonPressed(BUTTON0) && (currentCharFlag == 0))
   \                     ??UserAppSM_Idle_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       IsButtonPressed
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD018             BEQ.N    ??UserAppSM_Idle_1
   \   00000020   0x....             LDR.N    R0,??DataTable4_24
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD114             BNE.N    ??UserAppSM_Idle_1
    397            {
    398              PWMAudioOn(BUZZER1);
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       PWMAudioOn
    399              timeArray[timeCount] = G_u32SystemTime1ms; /* But how to make sure timeCount increments, but not every time it loops*/
   \   0000002E   0x....             LDR.N    R0,??DataTable4_25
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable4_26
   \   00000034   0x....             LDR.N    R2,??DataTable4_27
   \   00000036   0x7812             LDRB     R2,[R2, #+0]
   \   00000038   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    400              currentCharFlag = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable4_24
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    401              entryBegunFlag = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable4_28
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    402              timeCount++;
   \   00000048   0x....             LDR.N    R0,??DataTable4_27
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable4_27
   \   00000050   0x7008             STRB     R0,[R1, #+0]
    403              
    404            }
    405            if((!IsButtonPressed(BUTTON0)) && (currentCharFlag == 1))
   \                     ??UserAppSM_Idle_1: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       IsButtonPressed
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD115             BNE.N    ??UserAppSM_Idle_2
   \   0000005C   0x....             LDR.N    R0,??DataTable4_24
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD111             BNE.N    ??UserAppSM_Idle_2
    406            {
    407              //char* testmessage = "state2";
    408              //PixelAddressType test = {LCD_SMALL_FONT_LINE0,LCD_LEFT_MOST_COLUMN};
    409              //LcdLoadString(testmessage, LCD_FONT_SMALL, &test);
    410              PWMAudioOff(BUZZER1);
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x.... 0x....      BL       PWMAudioOff
    411              timeArray[timeCount] = G_u32SystemTime1ms;
   \   0000006A   0x....             LDR.N    R0,??DataTable4_25
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x....             LDR.N    R1,??DataTable4_26
   \   00000070   0x....             LDR.N    R2,??DataTable4_27
   \   00000072   0x7812             LDRB     R2,[R2, #+0]
   \   00000074   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    412              timeCount++;
   \   00000078   0x....             LDR.N    R0,??DataTable4_27
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0x....             LDR.N    R1,??DataTable4_27
   \   00000080   0x7008             STRB     R0,[R1, #+0]
    413              currentCharFlag = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x....             LDR.N    R1,??DataTable4_24
   \   00000086   0x7008             STRB     R0,[R1, #+0]
    414            }
    415            if((entryBegunFlag == 1) && (!IsButtonPressed(BUTTON0)) && ((G_u32SystemTime1ms - timeArray[timeCount - 1]) > BETWEEN_CHAR_TIME))
   \                     ??UserAppSM_Idle_2: (+1)
   \   00000088   0x....             LDR.N    R0,??DataTable4_28
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD11C             BNE.N    ??UserAppSM_Idle_3
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x.... 0x....      BL       IsButtonPressed
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD117             BNE.N    ??UserAppSM_Idle_3
   \   0000009A   0x....             LDR.N    R0,??DataTable4_25
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x....             LDR.N    R1,??DataTable4_26
   \   000000A0   0x....             LDR.N    R2,??DataTable4_27
   \   000000A2   0x7812             LDRB     R2,[R2, #+0]
   \   000000A4   0xEB11 0x0182      ADDS     R1,R1,R2, LSL #+2
   \   000000A8   0xF851 0x1C04      LDR      R1,[R1, #-4]
   \   000000AC   0x1A40             SUBS     R0,R0,R1
   \   000000AE   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000B2   0xD90A             BLS.N    ??UserAppSM_Idle_3
    416            {
    417              processCharacter(timeArray, timeCount);
   \   000000B4   0x....             LDR.N    R0,??DataTable4_27
   \   000000B6   0x7801             LDRB     R1,[R0, #+0]
   \   000000B8   0x....             LDR.N    R0,??DataTable4_26
   \   000000BA   0x.... 0x....      BL       processCharacter
    418              entryBegunFlag = 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x....             LDR.N    R1,??DataTable4_28
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    419              timeCount = 0;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x....             LDR.N    R1,??DataTable4_27
   \   000000C8   0x7008             STRB     R0,[R1, #+0]
    420            }
    421            
    422              
    423              
    424                      
    425            
    426            
    427          } /* end UserAppSM_Idle() */
   \                     ??UserAppSM_Idle_3: (+1)
   \   000000CA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??timeCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     ??timeArray:
   \   00000000                      DS8 48

   \                                 In section .bss, align 1
   \                     ??currentCharFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??entryBegunFlag:
   \   00000000                      DS8 1
    428          
    429          
    430          /*-------------------------------------------------------------------------------------------------------------------*/
    431          /* Handle an error */
    432          static void UserAppSM_Error(void)          
                             ^
Warning[Pe177]: function "UserAppSM_Error" was declared but never referenced

  static u32 UserApp_u32Timeout;                      /* Timeout counter used across states */
             ^
"C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\application\user_app.c",66  Warning[Pe177]: 
          variable "UserApp_u32Timeout" was declared but never referenced
    433          {
    434            UserApp_StateMachine = UserAppSM_Idle;
    435            
    436          } /* end UserAppSM_Error() */
    437          
    438          
    439          /*-------------------------------------------------------------------------------------------------------------------*/
    440          /* State to sit in if init failed */

   \                                 In section .text, align 4, keep-with-next
    441          static void UserAppSM_FailedInit(void)          
    442          {
    443              
    444          } /* end UserAppSM_FailedInit() */
   \                     UserAppSM_FailedInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     messageCharCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     messageArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     messageArray2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     messageArray3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     messageArray4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     messageArray5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x........         DC32     messageArray6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0x........         DC32     morseBinArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x........         DC32     morseCharArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_18:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_19:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_20:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_21:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_22:
   \   00000000   0x........         DC32     G_stAntSetupData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_23:
   \   00000000   0x........         DC32     UserApp_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_24:
   \   00000000   0x........         DC32     ??currentCharFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_25:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_26:
   \   00000000   0x........         DC32     ??timeArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_27:
   \   00000000   0x........         DC32     ??timeCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_28:
   \   00000000   0x........         DC32     ??entryBegunFlag

   \                                 In section .rodata, align 2
   \                     ?_0:
   \   00000000   0x20 0x00          DC8 " "

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x0008 0x0000      DC16 8, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x0010 0x0000      DC16 16, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x0018 0x0000      DC16 24, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x0020 0x0000      DC16 32, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x0028 0x0000      DC16 40, 0

   \                                 In section .rodata, align 4
   \   00000000   0x00               DC8 ""
   \   00000001   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x00               DC8 ""
   \   00000001   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x0008 0x0000      DC16 8, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x0010 0x0000      DC16 16, 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x0018 0x0000      DC16 24, 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x0020 0x0000      DC16 32, 0

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x0028 0x0000      DC16 40, 0
    445          
    446          
    447          /*--------------------------------------------------------------------------------------------------------------------*/
    448          /* End of File                                                                                                        */
    449          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UserAppInitialize
         8   -> AntChannelConfig
         8   -> AntOpenChannel
         8   -> LcdClearScreen
         8   -> PWMAudioSetFrequency
       8   UserAppRunActiveState
         8   -- Indirect call
       0   UserAppSM_FailedInit
       8   UserAppSM_Idle
         8   -> ButtonAcknowledge
         8   -> IsButtonPressed
         8   -> PWMAudioOff
         8   -> PWMAudioOn
         8   -> WasButtonPressed
         8   -> addSpace
         8   -> processCharacter
      32   addSpace
        32   -> LcdLoadString
        32   -> strcat
      64   processCharacter
        64   -> LcdLoadString
        64   -> strcat
        64   -> strcmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_19
       4  ??DataTable4_2
       4  ??DataTable4_20
       4  ??DataTable4_21
       4  ??DataTable4_22
       4  ??DataTable4_23
       4  ??DataTable4_24
       4  ??DataTable4_25
       4  ??DataTable4_26
       4  ??DataTable4_27
       4  ??DataTable4_28
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  ?_0
       4  ?_1
       4  ?_10
       4  ?_11
       4  ?_12
       4  ?_13
       4  ?_14
       4  ?_2
       4  ?_3
       4  ?_4
       4  ?_5
       4  ?_6
       8  ?_7
       2  ?_8
       4  ?_9
       4  G_u32UserAppFlags
     112  UserAppInitialize
      10  UserAppRunActiveState
       2  UserAppSM_FailedInit
     204  UserAppSM_Idle
       4  UserApp_StateMachine
     322  addSpace
       1  currentCharFlag
       1  entryBegunFlag
      28  messageArray
      28  messageArray2
      28  messageArray3
      28  messageArray4
      28  messageArray5
      28  messageArray6
       1  messageCharCount
     156  morseBinArray
      28  morseCharArray
     712  processCharacter
      48  timeArray
       1  timeCount

 
   228 bytes in section .bss
   184 bytes in section .data
    60 bytes in section .rodata
 1 478 bytes in section .text
 
 1 478 bytes of CODE  memory
    60 bytes of CONST memory
   412 bytes of DATA  memory

Errors: none
Warnings: 14
