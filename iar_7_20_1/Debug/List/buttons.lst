###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Apr/2016  16:27:44
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\drivers\buttons.c
#    Command line =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\drivers\buttons.c
#        --preprocess=cl
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -lC
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\
#        -o
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\ -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\bsp\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\drivers\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\application\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\libraries\captouch\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\List\buttons.lst
#    Object file  =  
#        C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpgl2\iar_7_20_1\Debug\Obj\buttons.o
#
###############################################################################

C:\Users\Theo\Documents\GitHub\MPGL2\firmware_mpg_common\drivers\buttons.c
      1          /***********************************************************************************************************************
      2          File: buttons.c                                                                
      3          
      4          Description:
      5          Button functions and state machine.  The application handles all debouncing and glitch filtering.
      6          
      7          ------------------------------------------------------------------------------------------------------------------------
      8          API:
      9          Types:
     10          The argument u32Button_ is either BUTTON0 or BUTTON1.  
     11          
     12          Public:
     13          bool IsButtonPressed(u32 u32Button_)
     14          Returns TRUE if Button_aeCurrentState[eButton_] is currently pressed (and debounced).
     15          
     16          bool WasButtonPressed(u32 u32Button_)
     17          Returns TRUE if a particular button was pressed since last time it was checked even if it is no longer pressed.
     18          ButtonAcknowledge is typically called immediately after WasButtonPressed() returns TRUE to clear the button
     19          pressed state.
     20          
     21          void ButtonAcknowledge(u32 u32Button_)
     22          Clears the New Press state of a button -- generally always called after WasButtonPressed() returns TRUE.
     23          
     24          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
     25          Returns TRUE if a button has been held for u32ButtonHeldTime_ time in milliseconds.
     26          
     27          Protected:
     28          void ButtonInitialize(void)
     29          Configures the button system for the product including enabling button GPIO interrupts.  
     30          
     31          u32 GetButtonBitLocation(u8 u8Button_, ButtonPortType ePort_)
     32          Returns the location of the button within its port (should be required only for interrupt service routines).  
     33          
     34          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     35          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     36          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     37          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     38          
     39          ***********************************************************************************************************************/
     40          
     41          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable10  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable10_1  ;; 0xe000e280
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     42          
     43          /***********************************************************************************************************************
     44          Global variable definitions with scope across entire project.
     45          All Global variable names shall start with "G_<type>Button"
     46          ***********************************************************************************************************************/
     47          /* New variables */

   \                                 In section .bss, align 2
     48          volatile bool G_abButtonDebounceActive[TOTAL_BUTTONS];           /* Flags for buttons being debounced */
   \                     G_abButtonDebounceActive:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     49          volatile u32 G_au32ButtonDebounceTimeStart[TOTAL_BUTTONS];       /* Button debounce start time */
   \                     G_au32ButtonDebounceTimeStart:
   \   00000000                      DS8 8
     50          
     51          /*--------------------------------------------------------------------------------------------------------------------*/
     52          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     53          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     54          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     55          
     56          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     57          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     58          
     59          
     60          /***********************************************************************************************************************
     61          Global variable definitions with scope limited to this local application.
     62          Variable names shall start with "Button_" and be declared as static.
     63          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     64          static fnCode_type Button_pfnStateMachine;                  /* The Button application state machine function pointer */
   \                     Button_pfnStateMachine:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 2
     66          static ButtonStateType Button_aeCurrentState[TOTAL_BUTTONS];/* Current pressed state of button */
   \                     Button_aeCurrentState:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     67          static ButtonStateType Button_aeNewState[TOTAL_BUTTONS];    /* New (pending) pressed state of button */
   \                     Button_aeNewState:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     68          static u32 Button_au32HoldTimeStart[TOTAL_BUTTONS];         /* System 1ms time when a button press started */
   \                     Button_au32HoldTimeStart:
   \   00000000                      DS8 8

   \                                 In section .bss, align 2
     69          static bool Button_abNewPress[TOTAL_BUTTONS];               /* Flags to indicate a button was pressed */    
   \                     Button_abNewPress:
   \   00000000                      DS8 2
     70          
     71          
     72          /************ %BUTTON% EDIT BOARD-SPECIFIC GPIO DEFINITIONS BELOW ***************/
     73          /* Add all of the GPIO pin names for the buttons in the system.  
     74          The order of the definitions below must match the order of the definitions provided in configuration.h */ 
     75          
     76          #ifdef MPGL1
     77          static const u32 Button_au32ButtonPins[TOTAL_BUTTONS] = 
     78          {
     79            PA_17_BUTTON0, PB_00_BUTTON1, PB_01_BUTTON2, PB_02_BUTTON3
     80          };
     81          
     82          /* Control array for all buttons in system initialized for ButtonInitialize().  Array values correspond to ButtonConfigType fields: 
     83               eActiveState       ePort                   */
     84          static ButtonConfigType Buttons_asArray[TOTAL_BUTTONS] = 
     85          {{BUTTON_ACTIVE_LOW, BUTTON_PORTA}, /* BUTTON0  */
     86           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON1  */
     87           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON2  */
     88           {BUTTON_ACTIVE_LOW, BUTTON_PORTB}, /* BUTTON3  */
     89          };   
     90          #endif /* MPGL1 */
     91          
     92          #ifdef MPGL2

   \                                 In section .rodata, align 4
     93          static const u32 Button_au32ButtonPins[TOTAL_BUTTONS] = 
   \                     Button_au32ButtonPins:
   \   00000000   0x00020000         DC32 131072, 1
   \              0x00000001   
     94          {
     95            PA_17_BUTTON0, PB_00_BUTTON1
     96          };
     97          
     98          /* Control array for all buttons in system initialized for ButtonInitialize().  Array values correspond to ButtonConfigType fields: 
     99               eActiveState       ePort                   */

   \                                 In section .data, align 4
    100          static ButtonConfigType Buttons_asArray[TOTAL_BUTTONS] = 
   \                     Buttons_asArray:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 128
   \              0x00 0x80    
    101          {{BUTTON_ACTIVE_LOW, BUTTON_PORTA}, /* BUTTON0  */
    102           {BUTTON_ACTIVE_LOW, BUTTON_PORTB} /* BUTTON1  */
    103          };   
    104          #endif /* MPGL2 */
    105          
    106          /************ EDIT BOARD-SPECIFIC GPIO DEFINITIONS ABOVE ***************/
    107          
    108          
    109          /***********************************************************************************************************************
    110          Function Definitions
    111          ***********************************************************************************************************************/
    112          /*--------------------------------------------------------------------------------------------------------------------*/
    113          /* Public Functions */
    114          /*--------------------------------------------------------------------------------------------------------------------*/
    115          
    116          /*----------------------------------------------------------------------------------------------------------------------
    117          Function: IsButtonPressed
    118          
    119          Description:
    120          Determine if a particular button is currently pressed at this moment in time.
    121          The button must still be pressed at the time of this inquiry for the function
    122          to return TRUE.
    123          
    124          Requires:
    125            - u32Button_ is a valid button index
    126            - Button_aeCurrentState[u32Button_] is valid
    127           
    128          Promises:
    129            - Returns TRUE if Button_aeCurrentState[eButton_] is pressed; otherwise returns FALSE
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          bool IsButtonPressed(u32 u32Button_)
    132          {
   \                     IsButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    133            if( Button_aeCurrentState[u32Button_] == PRESSED)
   \   00000002   0x....             LDR.N    R0,??DataTable10_2
   \   00000004   0x5C08             LDRB     R0,[R1, R0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??IsButtonPressed_0
    134            {
    135              return(TRUE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??IsButtonPressed_1
    136            }
    137            else
    138            {
    139              return(FALSE);
   \                     ??IsButtonPressed_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??IsButtonPressed_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    140            }
    141          
    142          } /* end IsButtonPressed() */
    143          
    144          
    145          /*----------------------------------------------------------------------------------------------------------------------
    146          Function: WasButtonPressed
    147          
    148          Description:
    149          Determines if a particular button was pressed since last time it was checked. 
    150          The button may or may not still be pressed when this inquiry is made.  Mulitple
    151          button presses are not tracked.  The user should call ButtonAcknowledge immediately
    152          following this function to clear the state.
    153          
    154          Requires:
    155            - u32 u32Button_ is a valid button index
    156            - Button_aeCurrentState[u32Button_] is valid
    157           
    158          Promises:
    159            - Returns TRUE if Button_abNewPress[u32Button_] is TRUE; other wise returns FALSE
    160          */

   \                                 In section .text, align 2, keep-with-next
    161          bool WasButtonPressed(u32 u32Button_)
    162          {
   \                     WasButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    163            if( Button_abNewPress[u32Button_] == TRUE)
   \   00000002   0x....             LDR.N    R0,??DataTable10_3
   \   00000004   0x5C08             LDRB     R0,[R1, R0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??WasButtonPressed_0
    164            {
    165              return(TRUE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??WasButtonPressed_1
    166            }
    167            else
    168            {
    169              return(FALSE);
   \                     ??WasButtonPressed_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??WasButtonPressed_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    170            }
    171          
    172          } /* end WasButtonPressed() */
    173          
    174          
    175          /*----------------------------------------------------------------------------------------------------------------------
    176          Function: ButtonAcknowledge
    177          
    178          Description:
    179          Clears the New Press state of a button.
    180          
    181          Requires:
    182            - u32Button_ is a valid button index
    183           
    184          Promises:
    185            - The flag at Button_abNewPress[eButton_] is set to FALSE
    186          */

   \                                 In section .text, align 2, keep-with-next
    187          void ButtonAcknowledge(u32 u32Button_)
    188          {
    189            Button_abNewPress[u32Button_] = FALSE;
   \                     ButtonAcknowledge: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable10_3
   \   00000004   0x5481             STRB     R1,[R0, R2]
    190          
    191          } /* end ButtonAcknowledge() */
   \   00000006   0x4770             BX       LR               ;; return
    192          
    193          
    194          /*----------------------------------------------------------------------------------------------------------------------
    195          Function: IsButtonHeld
    196          
    197          Description:
    198          Queries to see if a button has been held for a certain time.  The button
    199          must still be pressed when this function is called if it is to return TRUE.
    200          
    201          Requires:
    202            - u32Button_ is a valid button index
    203            - u32ButtonHeldTime is a time in ms 
    204           
    205          Promises:
    206            - Returns TRUE if eButton_ has been held longer than u32ButtonHeldTime_
    207          */

   \                                 In section .text, align 2, keep-with-next
    208          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
    209          {
   \                     IsButtonHeld: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    210           if( IsButtonPressed(u32Button_) && 
    211               IsTimeUp(&Button_au32HoldTimeStart[u32Button_], u32ButtonHeldTime_ ) )
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       IsButtonPressed
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??IsButtonHeld_0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x....             LDR.N    R0,??DataTable10_4
   \   00000014   0xEB10 0x0084      ADDS     R0,R0,R4, LSL #+2
   \   00000018   0x.... 0x....      BL       IsTimeUp
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??IsButtonHeld_0
    212           {
    213             return(TRUE);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??IsButtonHeld_1
    214           }
    215           else
    216           {
    217             return(FALSE);
   \                     ??IsButtonHeld_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??IsButtonHeld_1: (+1)
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    218           }
    219          
    220          } /* end IsButtonHeld() */
    221          
    222          
    223          /*--------------------------------------------------------------------------------------------------------------------*/
    224          /* Protected Functions */
    225          /*--------------------------------------------------------------------------------------------------------------------*/
    226          
    227          /*----------------------------------------------------------------------------------------------------------------------
    228          Function: ButtonInitialize
    229          
    230          Description:
    231          Configures the button system for the product including enabling button GPIO interrupts.  
    232          
    233          Requires:
    234            - GPIO configuration is already complete for all button inputs
    235            - Button interrupt initializations and handler functions are ready
    236           
    237          Promises:
    238            - G_abButtonDebounceActive, LGaeButtonPreviousState and Button_aeCurrentState 
    239              are intialized
    240            - GGstButtonTrackballPosition fields are all initialized to default values
    241            - The button state machine is initialized to Idle
    242          */

   \                                 In section .text, align 2, keep-with-next
    243          void ButtonInitialize(void)
    244          {
   \                     ButtonInitialize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    245            u32 u32PortAInterruptMask = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    246            u32 u32PortBInterruptMask = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    247            static u8 au8ButtonStartupMsg[] = "Button task ready\n\r";
    248            
    249            /* Setup default data for all of the buttons in the system */
    250            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000006   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_0: (+1)
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xDA0D             BGE.N    ??ButtonInitialize_1
    251            {
    252              G_abButtonDebounceActive[i] = FALSE;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x....             LDR.N    R2,??DataTable10_5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5481             STRB     R1,[R0, R2]
    253              Button_aeCurrentState[i]    = RELEASED;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x....             LDR.N    R2,??DataTable10_2
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x5481             STRB     R1,[R0, R2]
    254              Button_aeNewState[i]        = RELEASED;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x....             LDR.N    R2,??DataTable10_6
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x5481             STRB     R1,[R0, R2]
    255            }
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0xE7EE             B.N      ??ButtonInitialize_0
    256            
    257            /* Create masks based on any buttons in the system.  It's ok to have an empty mask. */
    258            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \                     ??ButtonInitialize_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_2: (+1)
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2802             CMP      R0,#+2
   \   00000030   0xDA1A             BGE.N    ??ButtonInitialize_3
    259            {
    260              if(Buttons_asArray[i].ePort == BUTTON_PORTA)
   \   00000032   0x....             LDR.N    R1,??DataTable10_7
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \   0000003A   0x7849             LDRB     R1,[R1, #+1]
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD105             BNE.N    ??ButtonInitialize_4
    261              {
    262                u32PortAInterruptMask |= Button_au32ButtonPins[i];
   \   00000040   0x....             LDR.N    R1,??DataTable10_8
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000048   0x430C             ORRS     R4,R1,R4
   \   0000004A   0xE00B             B.N      ??ButtonInitialize_5
    263              }
    264              else if(Buttons_asArray[i].ePort == BUTTON_PORTB)
   \                     ??ButtonInitialize_4: (+1)
   \   0000004C   0x....             LDR.N    R1,??DataTable10_7
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \   00000054   0x7849             LDRB     R1,[R1, #+1]
   \   00000056   0x2980             CMP      R1,#+128
   \   00000058   0xD104             BNE.N    ??ButtonInitialize_5
    265              {
    266                u32PortBInterruptMask |= Button_au32ButtonPins[i];
   \   0000005A   0x....             LDR.N    R1,??DataTable10_8
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000062   0x430D             ORRS     R5,R1,R5
    267              }
    268            }
   \                     ??ButtonInitialize_5: (+1)
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0xE7E1             B.N      ??ButtonInitialize_2
    269          
    270            /* Enable PIO interrupts */
    271            AT91C_BASE_PIOA->PIO_IER = u32PortAInterruptMask;
   \                     ??ButtonInitialize_3: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable10_9  ;; 0x400e0c40
   \   0000006A   0x6004             STR      R4,[R0, #+0]
    272            AT91C_BASE_PIOB->PIO_IER = u32PortBInterruptMask;
   \   0000006C   0x....             LDR.N    R0,??DataTable10_10  ;; 0x400e0e40
   \   0000006E   0x6005             STR      R5,[R0, #+0]
    273            
    274            /* Read the ISR register to clear all the current flags */
    275            u32PortAInterruptMask = AT91C_BASE_PIOA->PIO_ISR;
   \   00000070   0x....             LDR.N    R0,??DataTable10_11  ;; 0x400e0c4c
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0004             MOVS     R4,R0
    276            u32PortBInterruptMask = AT91C_BASE_PIOB->PIO_ISR;
   \   00000076   0x....             LDR.N    R0,??DataTable10_12  ;; 0x400e0e4c
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0005             MOVS     R5,R0
    277          
    278            /* Configure the NVIC to ensure the PIOA and PIOB interrupts are active */
    279            NVIC_ClearPendingIRQ(IRQn_PIOA);
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    280            NVIC_ClearPendingIRQ(IRQn_PIOB);
   \   00000082   0x200B             MOVS     R0,#+11
   \   00000084   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    281            NVIC_EnableIRQ(IRQn_PIOA);
   \   00000088   0x200A             MOVS     R0,#+10
   \   0000008A   0x.... 0x....      BL       NVIC_EnableIRQ
    282            NVIC_EnableIRQ(IRQn_PIOB);
   \   0000008E   0x200B             MOVS     R0,#+11
   \   00000090   0x.... 0x....      BL       NVIC_EnableIRQ
    283              
    284            /* Init complete: set function pointer and application flag */
    285            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000094   0x.... 0x....      ADR.W    R0,ButtonSM_Idle
   \   00000098   0x....             LDR.N    R1,??DataTable10_13
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    286            G_u32ApplicationFlags |= _APPLICATION_FLAGS_BUTTON;
   \   0000009C   0x....             LDR.N    R0,??DataTable10_14
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000A4   0x....             LDR.N    R1,??DataTable10_14
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    287            DebugPrintf(au8ButtonStartupMsg);
   \   000000A8   0x....             LDR.N    R0,??DataTable10_15
   \   000000AA   0x.... 0x....      BL       DebugPrintf
    288          
    289          } /* end ButtonInitialize() */
   \   000000AE   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     ??au8ButtonStartupMsg:
   \   00000000   0x42 0x75          DC8 "Button task ready\012\015"
   \              0x74 0x74    
   \              0x6F 0x6E    
   \              0x20 0x74    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    290          
    291          
    292          /*----------------------------------------------------------------------------------------------------------------------
    293          Function ButtonRunActiveState()
    294          
    295          Description:
    296          Selects and runs one iteration of the current state in the state machine.
    297          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    298          may take 1ms / n to execute.
    299          
    300          Requires:
    301            - State machine function pointer points at current state
    302          
    303          Promises:
    304            - Calls the function to pointed by the state machine function pointer
    305          */

   \                                 In section .text, align 2, keep-with-next
    306          void ButtonRunActiveState(void)
    307          {
   \                     ButtonRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    308            Button_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable10_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    309          
    310          } /* end ButtonRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    311          
    312          
    313          /*----------------------------------------------------------------------------------------------------------------------
    314          Function: GetButtonBitLocation
    315          
    316          Description:
    317          Returns the location of the button within its port.  
    318          The GPIO interrupt requires access to this function.
    319          
    320          Requires:
    321            - u8Button_ is a valid ButtonNumberType.
    322            - ePort_ is the port where the button is located
    323          
    324          Promises:
    325            - Returns a value that has a bit set in the corresponding position of u32Button_ on the button's port
    326            - Returns 0 if no match
    327          */

   \                                 In section .text, align 2, keep-with-next
    328          u32 GetButtonBitLocation(u8 u8Button_, ButtonPortType ePort_)
    329          {
   \                     GetButtonBitLocation: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    330            /* Make sure the index is valid */
    331            if(u8Button_ < TOTAL_BUTTONS) 
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A02             CMP      R2,#+2
   \   00000006   0xDA0C             BGE.N    ??GetButtonBitLocation_0
    332            {
    333              /* Index is valid so check that the button exists on the port */
    334              if(Buttons_asArray[u8Button_].ePort == ePort_)
   \   00000008   0x....             LDR.N    R0,??DataTable10_7
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xEB10 0x0042      ADDS     R0,R0,R2, LSL #+1
   \   00000010   0x7840             LDRB     R0,[R0, #+1]
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD104             BNE.N    ??GetButtonBitLocation_0
    335              {
    336                /* Return the button position if the index is the correct port */
    337                return(Button_au32ButtonPins[u8Button_]);
   \   00000018   0x....             LDR.N    R0,??DataTable10_8
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000020   0xE000             B.N      ??GetButtonBitLocation_1
    338              }
    339            }
    340            
    341            /* Otherwise return 0 */
    342            return(0);
   \                     ??GetButtonBitLocation_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??GetButtonBitLocation_1: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    343            
    344          } /* end GetButtonBitLocation() */
    345          
    346          
    347          /*--------------------------------------------------------------------------------------------------------------------*/
    348          /* Private functions */
    349          /*--------------------------------------------------------------------------------------------------------------------*/
    350          
    351          
    352          /***********************************************************************************************************************
    353          State Machine Function Definitions
    354          
    355          The button state machine monitors button activity and manages debouncing and
    356          maintaining the global button states.
    357          ***********************************************************************************************************************/
    358          
    359          /*--------------------------------------------------------------------------------------------------------------------*/
    360          /* Do nothing but wait for a debounce time to start */

   \                                 In section .text, align 4, keep-with-next
    361          static void ButtonSM_Idle(void)                
    362          {
    363            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \                     ButtonSM_Idle: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??ButtonSM_Idle_0: (+1)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xDA0A             BGE.N    ??ButtonSM_Idle_1
    364            {
    365              if(G_abButtonDebounceActive[i])
   \   00000008   0x....             LDR.N    R1,??DataTable10_5
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x5C41             LDRB     R1,[R0, R1]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD003             BEQ.N    ??ButtonSM_Idle_2
    366              {
    367                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   00000012   0x.... 0x....      ADR.W    R1,ButtonSM_ButtonActive
   \   00000016   0x....             LDR.N    R2,??DataTable10_13
   \   00000018   0x6011             STR      R1,[R2, #+0]
    368              }
    369            }
   \                     ??ButtonSM_Idle_2: (+1)
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xE7F1             B.N      ??ButtonSM_Idle_0
    370            
    371          } /* end ButtonSM_Idle(void) */
   \                     ??ButtonSM_Idle_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    372          
    373          
    374          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    375          static void ButtonSM_ButtonActive(void)         
    376          {
   \                     ButtonSM_ButtonActive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    377            u32 *pu32PortAddress;
    378            u32 *pu32InterruptAddress;
    379          
    380            /* Start by resseting back to Idle in case no buttons are active */
    381            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable10_16
   \   00000004   0x....             LDR.N    R1,??DataTable10_13
   \   00000006   0x6008             STR      R0,[R1, #+0]
    382          
    383            /* Check for buttons that are debouncing */
    384            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000008   0x2600             MOVS     R6,#+0
   \                     ??ButtonSM_ButtonActive_0: (+1)
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x2E02             CMP      R6,#+2
   \   0000000E   0xDA74             BGE.N    ??ButtonSM_ButtonActive_1
    385            {
    386              /* Load address offsets for the current button */
    387              pu32PortAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_PDSR) + Buttons_asArray[i].ePort);
   \   00000010   0x....             LDR.N    R0,??DataTable10_17  ;; 0x400e0c3c
   \   00000012   0x....             LDR.N    R1,??DataTable10_7
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   0000001A   0x7849             LDRB     R1,[R1, #+1]
   \   0000001C   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   00000020   0x0004             MOVS     R4,R0
    388              pu32InterruptAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_IER) + Buttons_asArray[i].ePort);
   \   00000022   0x....             LDR.N    R0,??DataTable10_9  ;; 0x400e0c40
   \   00000024   0x....             LDR.N    R1,??DataTable10_7
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   0000002C   0x7849             LDRB     R1,[R1, #+1]
   \   0000002E   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   00000032   0x0005             MOVS     R5,R0
    389              
    390              if( G_abButtonDebounceActive[i] )
   \   00000034   0x....             LDR.N    R0,??DataTable10_5
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x5C30             LDRB     R0,[R6, R0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD05B             BEQ.N    ??ButtonSM_ButtonActive_2
    391              {
    392                /* Still have an active button */
    393                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   0000003E   0x....             LDR.N    R0,??DataTable10_18
   \   00000040   0x....             LDR.N    R1,??DataTable10_13
   \   00000042   0x6008             STR      R0,[R1, #+0]
    394                
    395                if( IsTimeUp((u32*)&G_au32ButtonDebounceTimeStart[i], BUTTON_DEBOUNCE_TIME) )
   \   00000044   0x2119             MOVS     R1,#+25
   \   00000046   0x....             LDR.N    R0,??DataTable10_19
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   0000004E   0x.... 0x....      BL       IsTimeUp
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD04F             BEQ.N    ??ButtonSM_ButtonActive_2
    396                {
    397                  /* Active low: get current state of button */
    398                  if(Buttons_asArray[i].eActiveState == BUTTON_ACTIVE_LOW)
   \   00000056   0x....             LDR.N    R0,??DataTable10_7
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0xF810 0x0016      LDRB     R0,[R0, R6, LSL #+1]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD111             BNE.N    ??ButtonSM_ButtonActive_3
    399                  {
    400                    if( ~(*pu32PortAddress) & Button_au32ButtonPins[i] )
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x43C0             MVNS     R0,R0
   \   00000066   0x....             LDR.N    R1,??DataTable10_8
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   0000006E   0x4208             TST      R0,R1
   \   00000070   0xD004             BEQ.N    ??ButtonSM_ButtonActive_4
    401                    {          
    402                      Button_aeNewState[i] = PRESSED;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x....             LDR.N    R1,??DataTable10_6
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x5470             STRB     R0,[R6, R1]
   \   0000007A   0xE014             B.N      ??ButtonSM_ButtonActive_5
    403                    }
    404                    else
    405                    {
    406                      Button_aeNewState[i] = RELEASED;
   \                     ??ButtonSM_ButtonActive_4: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x....             LDR.N    R1,??DataTable10_6
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x5470             STRB     R0,[R6, R1]
   \   00000084   0xE00F             B.N      ??ButtonSM_ButtonActive_5
    407                    }
    408                  }
    409                  /* Active high */
    410                  else
    411                  {
    412                    if( *pu32PortAddress & Button_au32ButtonPins[i] )
   \                     ??ButtonSM_ButtonActive_3: (+1)
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x....             LDR.N    R1,??DataTable10_8
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   00000090   0x4208             TST      R0,R1
   \   00000092   0xD004             BEQ.N    ??ButtonSM_ButtonActive_6
    413                    {          
    414                      Button_aeNewState[i] = PRESSED;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x....             LDR.N    R1,??DataTable10_6
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x5470             STRB     R0,[R6, R1]
   \   0000009C   0xE003             B.N      ??ButtonSM_ButtonActive_5
    415                    }
    416                    else
    417                    {
    418                      Button_aeNewState[i] = RELEASED;
   \                     ??ButtonSM_ButtonActive_6: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x....             LDR.N    R1,??DataTable10_6
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x5470             STRB     R0,[R6, R1]
    419                    }
    420                  }
    421                  
    422                  /* Update if the button state has changed */
    423                  if( Button_aeNewState[i] != Button_aeCurrentState[i] )
   \                     ??ButtonSM_ButtonActive_5: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable10_6
   \   000000A8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AA   0x5C30             LDRB     R0,[R6, R0]
   \   000000AC   0x....             LDR.N    R1,??DataTable10_2
   \   000000AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B0   0x5C71             LDRB     R1,[R6, R1]
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD014             BEQ.N    ??ButtonSM_ButtonActive_7
    424                  {
    425                    Button_aeCurrentState[i] = Button_aeNewState[i];
   \   000000B6   0x....             LDR.N    R0,??DataTable10_6
   \   000000B8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BA   0x5C30             LDRB     R0,[R6, R0]
   \   000000BC   0x....             LDR.N    R1,??DataTable10_2
   \   000000BE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C0   0x5470             STRB     R0,[R6, R1]
    426                    if(Button_aeCurrentState[i] == PRESSED)
   \   000000C2   0x....             LDR.N    R0,??DataTable10_2
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0x5C30             LDRB     R0,[R6, R0]
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD109             BNE.N    ??ButtonSM_ButtonActive_7
    427                    {
    428                      Button_abNewPress[i] = TRUE;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x....             LDR.N    R1,??DataTable10_3
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x5470             STRB     R0,[R6, R1]
    429                      Button_au32HoldTimeStart[i] = G_u32SystemTime1ms;
   \   000000D4   0x....             LDR.N    R0,??DataTable10_20
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x....             LDR.N    R1,??DataTable10_4
   \   000000DA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DC   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
    430                    }
    431                  }
    432          
    433                  /* Regardless of a good press or not, clear the debounce active flag and re-enable the interrupts */
    434                  G_abButtonDebounceActive[i] = FALSE;
   \                     ??ButtonSM_ButtonActive_7: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x....             LDR.N    R1,??DataTable10_5
   \   000000E4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E6   0x5470             STRB     R0,[R6, R1]
    435                  *pu32InterruptAddress |= Button_au32ButtonPins[i];
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x....             LDR.N    R1,??DataTable10_8
   \   000000EC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EE   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \   000000F2   0x4308             ORRS     R0,R1,R0
   \   000000F4   0x6028             STR      R0,[R5, #+0]
    436                  
    437                } /* end if( IsTimeUp...) */
    438              } /* end if(G_abButtonDebounceActive[index]) */
    439            } /* end for i */
   \                     ??ButtonSM_ButtonActive_2: (+1)
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
   \   000000F8   0xE787             B.N      ??ButtonSM_ButtonActive_0
    440            
    441          } /* end ButtonSM_ButtonActive() */
   \                     ??ButtonSM_ButtonActive_1: (+1)
   \   000000FA   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Button_aeCurrentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Button_abNewPress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     Button_au32HoldTimeStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     G_abButtonDebounceActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     Button_aeNewState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     Buttons_asArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     Button_au32ButtonPins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x400E0C40         DC32     0x400e0c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x400E0E40         DC32     0x400e0e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x400E0C4C         DC32     0x400e0c4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x400E0E4C         DC32     0x400e0e4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     Button_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     ??au8ButtonStartupMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     ButtonSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x400E0C3C         DC32     0x400e0c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x........         DC32     ButtonSM_ButtonActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x........         DC32     G_au32ButtonDebounceTimeStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x........         DC32     G_u32SystemTime1ms
    442          
    443          
    444          
    445          /*--------------------------------------------------------------------------------------------------------------------*/
    446          /* End of File */
    447          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ButtonAcknowledge
      16   ButtonInitialize
        16   -> DebugPrintf
        16   -> NVIC_ClearPendingIRQ
        16   -> NVIC_EnableIRQ
       8   ButtonRunActiveState
         8   -- Indirect call
      16   ButtonSM_ButtonActive
        16   -> IsTimeUp
       0   ButtonSM_Idle
       0   GetButtonBitLocation
      16   IsButtonHeld
        16   -> IsButtonPressed
        16   -> IsTimeUp
       0   IsButtonPressed
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
       0   WasButtonPressed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       8  ButtonAcknowledge
     176  ButtonInitialize
      10  ButtonRunActiveState
     252  ButtonSM_ButtonActive
      32  ButtonSM_Idle
       2  Button_abNewPress
       2  Button_aeCurrentState
       2  Button_aeNewState
       8  Button_au32ButtonPins
       8  Button_au32HoldTimeStart
       4  Button_pfnStateMachine
       4  Buttons_asArray
       2  G_abButtonDebounceActive
       8  G_au32ButtonDebounceTimeStart
      38  GetButtonBitLocation
      40  IsButtonHeld
      18  IsButtonPressed
      20  NVIC_ClearPendingIRQ
      20  NVIC_EnableIRQ
      18  WasButtonPressed
      20  au8ButtonStartupMsg

 
  28 bytes in section .bss
  24 bytes in section .data
   8 bytes in section .rodata
 716 bytes in section .text
 
 716 bytes of CODE  memory
   8 bytes of CONST memory
  52 bytes of DATA  memory

Errors: none
Warnings: none
